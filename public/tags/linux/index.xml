<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Yet another enthusiast blog!</title>
    <link>http://blog.yadutaf.fr/tags/linux/</link>
    <description>Recent content in Linux on Yet another enthusiast blog!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Mar 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://blog.yadutaf.fr/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How to turn any syscall into an event: Introducing eBPF Kernel probes</title>
      <link>http://blog.yadutaf.fr/2016/03/30/turn-any-syscall-into-event-introducing-ebpf-kernel-probes/</link>
      <pubDate>Wed, 30 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.yadutaf.fr/2016/03/30/turn-any-syscall-into-event-introducing-ebpf-kernel-probes/</guid>
      <description>

&lt;p&gt;TL;DR: Using eBPF in recent (&amp;gt;=4.4) Linux kernel, you can turn any kernel function call into a user land event with arbitrary data. This is made easy by bcc. The probe is written in C while the data is handled by python.&lt;/p&gt;

&lt;p&gt;If you are not familiar with eBPF or linux tracing, you really should read the full post. It tries to progressively go through the pitfalls I stumbled unpon while playing around with bcc / eBPF while saving you a lot of the time I spent searching and digging.&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-push-vs-pull-in-a-linux-world:30fe7a87f2e63f2b769ee3edffa56012&#34;&gt;A note on push vs pull in a Linux world&lt;/h3&gt;

&lt;p&gt;When I started to work on containers, I was wondering how we could update a load balancer configuration dynamically based on actual system state. A common strategy, which works, it to let the container orchestrator trigger a load balancer configuration update whenever it starts a container and then let the load balancer poll the container until some health check passes. It may be a simple &amp;ldquo;SYN&amp;rdquo; test.&lt;/p&gt;

&lt;p&gt;While this configuration works, it has the downside of making your load balancer waiting for some system to be available while it should be&amp;hellip; load balancing.&lt;/p&gt;

&lt;p&gt;Can we do better?&lt;/p&gt;

&lt;p&gt;When you want a program to react to some change in a system there are 2 possible strategies. The program may &lt;em&gt;poll&lt;/em&gt; the system to detect changes or, if the system supports it, the system may &lt;em&gt;push&lt;/em&gt; events and let the program react to them. Wether you want to use push or poll depends on the context. A good rule of the thumb is to use push events when the event rate is low with respect to the processing time and switch to polling when the events are coming fast or the system may become unusable. For example, typical network driver will wait for events from the network card while frameworks like dpdk will actively poll the card for events to achieve the highest throughput and lowest latency.&lt;/p&gt;

&lt;p&gt;In an ideal world, we&amp;rsquo;d have some kernel interface telling us:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Hey Mr. ContainerManager, I&amp;rsquo;ve just created a socket for the Nginx-ware of container &lt;em&gt;servestaticfiles&lt;/em&gt;, maybe you want to update your state?&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Sure Mr. OS, Thanks for letting me know&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;While Linux has a wide range of interfaces to deal with events, up to 3 for file events, there is no dedicated interface to get socket event notifications. You can get routing table events, neighbor table events, conntrack events, interface change events. Just, not socket events. Or maybe there is, deep hidden in a Netlink interface.&lt;/p&gt;

&lt;p&gt;Ideally, we&amp;rsquo;d need a generic way to do it. How?&lt;/p&gt;

&lt;h3 id=&#34;kernel-tracing-and-ebpf-a-bit-of-history:30fe7a87f2e63f2b769ee3edffa56012&#34;&gt;Kernel tracing and eBPF, a bit of history&lt;/h3&gt;

&lt;p&gt;Until recently the only way was to patch the kernel or resort on SystemTap. &lt;a href=&#34;https://en.wikipedia.org/wiki/SystemTap&#34;&gt;SytemTap&lt;/a&gt; is a tracing Linux system. In a nutshell, it provides a DSL which is then compiled into a kernel module which is then live-loaded into the running kernel. Except that some production system disable dynamic module loading for security reasons. Including the one I was working on at that time. The other way would be to patch the kernel to trigger some events, probably based on netlink. This is not really convenient. Kernel hacking come with downsides including &amp;ldquo;interesting&amp;rdquo; new &amp;ldquo;features&amp;rdquo; and increased maintenance burden.&lt;/p&gt;

&lt;p&gt;Hopefully, starting with Linux 3.15 the ground was laid to safely transform any traceable kernel function into userland events. &amp;ldquo;Safely&amp;rdquo; is common computer science expression referring to &amp;ldquo;some virtual machine&amp;rdquo;. This case is no exception. Linux has had one for years. Since Linux 2.1.75 released in 1997 actually. It&amp;rsquo;s called Berkeley Packet Filter of BPF for short. As its name suggests, it was originally developed for the BSD firewalls. It had only 2 registers and only allowed forward jumps meaning that you could not write loops with it (Well, you can, if you know the maximum iterations and you manually unroll them). The point was to guarantee the program would always terminate and hence never hang the system. Still not sure if it has any use while you have iptables? It serves as the &lt;a href=&#34;https://blog.cloudflare.com/bpf-the-forgotten-bytecode/&#34;&gt;foundation of CloudFlare&amp;rsquo;s AntiDDos protection&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;OK, so, with Linux the 3.15, &lt;a href=&#34;TODO&#34;&gt;BPF was extended&lt;/a&gt; turning it into eBPF. For &amp;ldquo;extended&amp;rdquo; BPF. It upgrades from 2 32 bits registers to 10 64 bits 64 registers and adds backward jumping among others. It has then been &lt;a href=&#34;https://lwn.net/Articles/604043/&#34;&gt;further extended in Linux 3.18&lt;/a&gt; moving it out of the networking subsystem, and adding tools like maps. To preserve the safety guarantees, it &lt;a href=&#34;http://lxr.free-electrons.com/source/kernel/bpf/verifier.c#L21&#34;&gt;introduces a checker&lt;/a&gt; which validates all memory accesses and possible code path. If the checker can&amp;rsquo;t guarantee the code will terminate within fixed boundaries, it will deny the initial insertion of the program.&lt;/p&gt;

&lt;p&gt;For more history, there is &lt;a href=&#34;http://events.linuxfoundation.org/sites/events/files/slides/tracing-linux-ezannoni-linuxcon-ja-2015_0.pdf&#34;&gt;an excellent Oracle presentation on eBPF&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started.&lt;/p&gt;

&lt;h3 id=&#34;hello-from-from-inet-listen:30fe7a87f2e63f2b769ee3edffa56012&#34;&gt;Hello from from &lt;code&gt;inet_listen&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;As writing assembly is not the most convenient task, even for the best of us, we&amp;rsquo;ll use &lt;a href=&#34;https://github.com/iovisor/bcc&#34;&gt;bcc&lt;/a&gt;. bcc is a collection of tools based on LLVM and Python abstracting the underlying machinery. Probes are written in C and the results can be exploited from python allowing to easily write non trivial applications.&lt;/p&gt;

&lt;p&gt;Start by install bcc. For some of these examples, you may require a recent (read &amp;gt;= 4.4) version of the kernel. If you are willing to actually try these examples, I highly recommend that you setup a VM. &lt;em&gt;NOT&lt;/em&gt; a docker container. You can&amp;rsquo;t change the kernel in a container. As this is a young and dynamic projects, install instructions are highly platform/version dependant. You can find up to date instructions on &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/INSTALL.md&#34;&gt;https://github.com/iovisor/bcc/blob/master/INSTALL.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So, we want to get an event whenever a program starts to listen on TCP socket. When calling the &lt;code&gt;listen()&lt;/code&gt; syscall on a &lt;code&gt;AF_INET&lt;/code&gt; + &lt;code&gt;SOCK_STREAM&lt;/code&gt; socket, the underlying kernel function is &lt;a href=&#34;http://lxr.free-electrons.com/source/net/ipv4/af_inet.c#L194&#34;&gt;&lt;code&gt;inet_listen&lt;/code&gt;&lt;/a&gt;. We&amp;rsquo;ll start by hooking a &amp;ldquo;Hello World&amp;rdquo; &lt;code&gt;kprobe&lt;/code&gt; on it&amp;rsquo;s entrypoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from bcc import BPF

# Hello BPF Program
bpf_text = &amp;quot;&amp;quot;&amp;quot; 
#include &amp;lt;net/inet_sock.h&amp;gt;
#include &amp;lt;bcc/proto.h&amp;gt;

// 1. Attach kprobe to &amp;quot;inet_listen&amp;quot;
int kprobe__inet_listen(struct pt_regs *ctx, struct socket *sock, int backlog)
{
    bpf_trace_printk(&amp;quot;Hello World!\\n&amp;quot;);
    return 0;
};
&amp;quot;&amp;quot;&amp;quot;

# 2. Build and Inject program
b = BPF(text=bpf_text)

# 3. Print debug output
while True:
    print b.trace_readline()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program does 3 things:
1. It attaches a kernel probe to &amp;ldquo;inet_listen&amp;rdquo; using a naming convention. If the function was called, say, &amp;ldquo;my_probe&amp;rdquo;, it could be explicitly attached with &lt;code&gt;b.attach_kprobe(&amp;quot;inet_listen&amp;quot;, &amp;quot;my_probe&amp;quot;&lt;/code&gt;.
2. It builds the program using LLVM new BPF backend, inject the resulting bytecode using the (new) &lt;code&gt;bpf()&lt;/code&gt; syscall and automatically attaches the probes matching the naming convention.
3. It reads the raw output from the kernel pipe.&lt;/p&gt;

&lt;p&gt;Note: eBPF backend of LLVM is still young. If you think you&amp;rsquo;ve hit a bug, you may want to upgrade.&lt;/p&gt;

&lt;p&gt;Noticed the &lt;code&gt;bpf_trace_printk&lt;/code&gt; call? This is a stripped down version of the kernel&amp;rsquo;s &lt;code&gt;printk()&lt;/code&gt; debug function. When used, it produces tracing informations to a special kernel pipe in &lt;code&gt;/sys/kernel/debug/tracing/trace_pipe&lt;/code&gt;. As the name implies, this is a pipe. If multiple readers are consuming it, only 1 will get a given line. This makes it unsuitable for production.&lt;/p&gt;

&lt;p&gt;Fortunately, Linux 3.19 introduced maps for message passing and Linux 4.4 brings arbitrary perf events support. I&amp;rsquo;ll demo the perf event based approach later in this post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# From a first console
ubuntu@bcc:~/dev/listen-evts$ sudo /python tcv4listen.py 
              nc-4940  [000] d... 22666.991714: : Hello World!
 
# From a second console
ubuntu@bcc:~$ nc -l 0 4242
^C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yay!&lt;/p&gt;

&lt;h3 id=&#34;grab-the-backlog:30fe7a87f2e63f2b769ee3edffa56012&#34;&gt;Grab the backlog&lt;/h3&gt;

&lt;p&gt;Now, let&amp;rsquo;s print some easily accessible data. Say the &amp;ldquo;backlog&amp;rdquo;. The backlog is the number of pending established TCP connections, pending to be &lt;code&gt;accept()&lt;/code&gt;ed.&lt;/p&gt;

&lt;p&gt;Just tweak a bit the &lt;code&gt;bpf_trace_printk&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bpf_trace_printk(&amp;quot;Listening with with up to %d pending connections!\\n&amp;quot;, backlog);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you re-run the example with this world-changing improvement, you should see something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(bcc)ubuntu@bcc:~/dev/listen-evts$ sudo python tcv4listen.py 
              nc-5020  [000] d... 25497.154070: : Listening with with up to 1 pending connections!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nc&lt;/code&gt; is a single connection program, hence the backlog of 1. Nginx or Redis would output 128 here. But that&amp;rsquo;s another story.&lt;/p&gt;

&lt;p&gt;Easy hue? Now let&amp;rsquo;s get the port.&lt;/p&gt;

&lt;h3 id=&#34;grab-the-port-and-ip:30fe7a87f2e63f2b769ee3edffa56012&#34;&gt;Grab the port and IP&lt;/h3&gt;

&lt;p&gt;Studying &lt;code&gt;inet_listen&lt;/code&gt; source from the kernel, we know that we need to get the &lt;code&gt;inet_sock&lt;/code&gt; from the &lt;code&gt;socket&lt;/code&gt; object. Just copy from the sources, and insert at the beginning of the tracer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// cast types. Intermediate cast not needed, kept for readability
struct sock *sk = sock-&amp;gt;sk;
struct inet_sock *inet = inet_sk(sk);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The port can now be accessed from &lt;code&gt;inet-&amp;gt;inet_sport&lt;/code&gt; in network byte order (aka: Big Endian). Easy! So, we could just replace the &lt;code&gt;bpf_trace_printk&lt;/code&gt; with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bpf_trace_printk(&amp;quot;Listening on port %d!\\n&amp;quot;, inet-&amp;gt;inet_sport);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ubuntu@bcc:~/dev/listen-evts$ sudo /python tcv4listen.py 
...
R1 invalid mem access &#39;inv&#39;
...
Exception: Failed to load BPF program kprobe__inet_listen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Except that it&amp;rsquo;s not (yet) so simple. Bcc is improving a &lt;em&gt;lot&lt;/em&gt; currently. While writing this post, a couple of pitfalls had already been addressed. But not yet all. This Error means the in-kernel checker could prove the memory accesses in program are correct. See the explicit cast. We need to help is a little by making the accesses more explicit. We&amp;rsquo;ll use &lt;code&gt;bpf_probe_read&lt;/code&gt; trusted function to read an arbitrary memory location while guaranteeing all necessary checks are done with something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Explicit initialization. The &amp;quot;=0&amp;quot; part is needed to &amp;quot;give life&amp;quot; to the variable on the stack
u16 lport = 0;

// Explicit arbitrary memory access. Read it:
//    Read into &#39;lport&#39;, &#39;sizeof(lport)&#39; bytes from &#39;inet-&amp;gt;inet_sport&#39; memory location
bpf_probe_read(&amp;amp;lport, sizeof(lport), &amp;amp;(inet-&amp;gt;inet_sport));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reading the bound address for IPv4 is basically the same, using &lt;code&gt;inet-&amp;gt;inet_rcv_saddr&lt;/code&gt;. If we put is all together, we should get the backlog, the port and the bound IP:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from bcc import BPF  
  
# BPF Program  
bpf_text = &amp;quot;&amp;quot;&amp;quot;   
#include &amp;lt;net/sock.h&amp;gt;  
#include &amp;lt;net/inet_sock.h&amp;gt;  
#include &amp;lt;bcc/proto.h&amp;gt;  
  
// Send an event for each IPv4 listen with PID, bound address and port  
int kprobe__inet_listen(struct pt_regs *ctx, struct socket *sock, int backlog)  
{  
    // Cast types. Intermediate cast not needed, kept for readability  
    struct sock *sk = sock-&amp;gt;sk;  
    struct inet_sock *inet = inet_sk(sk);  

    // Working values. You *need* to initialize them to give them &amp;quot;life&amp;quot; on the stack and use them afterward  
    u32 laddr = 0;  
    u16 lport = 0;  

    // Pull in details. As &#39;inet_sk&#39; is internally a type cast, we need to use &#39;bpf_probe_read&#39;  
    // read: load into &#39;laddr&#39; &#39;sizeof(laddr)&#39; bytes from address &#39;inet-&amp;gt;inet_rcv_saddr&#39;  
    bpf_probe_read(&amp;amp;laddr, sizeof(laddr), &amp;amp;(inet-&amp;gt;inet_rcv_saddr));  
    bpf_probe_read(&amp;amp;lport, sizeof(lport), &amp;amp;(inet-&amp;gt;inet_sport));  

    // Push event
    bpf_trace_printk(&amp;quot;Listening on %x %d with %d pending connections\\n&amp;quot;, ntohl(laddr), ntohs(lport), backlog);  
    return 0;
};  
&amp;quot;&amp;quot;&amp;quot;  
  
# Build and Inject BPF  
b = BPF(text=bpf_text)  
  
# Print debug output  
while True:  
  print b.trace_readline()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A test run should output something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(bcc)ubuntu@bcc:~/dev/listen-evts$ sudo python tcv4listen.py 
              nc-5024  [000] d... 25821.166286: : Listening on 7f000001 4242 with 1 pending connections
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Provided that you listen on localhost. The address is displayed as hex here to avoid dealing with the IP pretty printing but that&amp;rsquo;s all wired. And that&amp;rsquo;s cool.&lt;/p&gt;

&lt;p&gt;Note: you may wonder why &lt;code&gt;ntohs&lt;/code&gt; and &lt;code&gt;ntohl&lt;/code&gt; can be called from BPF while they are not trusted. This is because they are macros and inline functions from &amp;ldquo;.h&amp;rdquo; files and a small bug was &lt;a href=&#34;https://github.com/iovisor/bcc/pull/453&#34;&gt;fixed&lt;/a&gt; while writing this post.&lt;/p&gt;

&lt;p&gt;All done, one more piece: We want to get the related container. In the context of networking, that&amp;rsquo;s means we want the network namespace. The network namespace being the building block of containers allowing them to have isolated networks.&lt;/p&gt;

&lt;h3 id=&#34;grab-the-network-namespace-a-forced-introduction-to-perf-events:30fe7a87f2e63f2b769ee3edffa56012&#34;&gt;Grab the network namespace: a forced introduction to perf events&lt;/h3&gt;

&lt;p&gt;On the userland, the network namespace can be determined by checking the target of &lt;code&gt;/proc/PID/ns/net&lt;/code&gt;. It should look like &lt;code&gt;net:[4026531957]&lt;/code&gt;. The number between brackets is the inode number of the network namespace. This said, we could grab it by scrapping &amp;lsquo;/proc&amp;rsquo; but this is racy, we may be dealing with short-lived processes. And races are never good. We&amp;rsquo;ll grab the inode number directly from the kernel. Fortunately, that&amp;rsquo;s an easy one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Create an populate the variable
u32 netns = 0;

// Read the netns inode number, like /proc does
netns = sk-&amp;gt;__sk_common.skc_net.net-&amp;gt;ns.inum;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Easy. And it works.&lt;/p&gt;

&lt;p&gt;But if you&amp;rsquo;ve read so far, you may guess there is something wrong somewhere. And there is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bpf_trace_printk(&amp;quot;Listening on %x %d with %d pending connections in container %d\\n&amp;quot;, ntohl(laddr), ntohs(lport), backlog, netns);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you try to run it, you&amp;rsquo;ll get some cryptic error message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(bcc)ubuntu@bcc:~/dev/listen-evts$ sudo python tcv4listen.py
error: in function kprobe__inet_listen i32 (%struct.pt_regs*, %struct.socket*, i32)
too many args to 0x1ba9108: i64 = Constant&amp;lt;6&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What clang is trying to tell you is &amp;ldquo;Hey pal, &lt;code&gt;bpf_trace_printk&lt;/code&gt; can only take 4 arguments, you&amp;rsquo;ve just used 5.&amp;ldquo;. I won&amp;rsquo;t dive into the details here, but that&amp;rsquo;s a BPF limitation. If you want to dig it, &lt;a href=&#34;http://lxr.free-electrons.com/source/kernel/trace/bpf_trace.c#L86&#34;&gt;here is a good starting point&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The only way to fix it is to&amp;hellip; stop debugging and make it production ready. So let&amp;rsquo;s get started (and make sure run at least Linux 4.4). We&amp;rsquo;ll use perf events which supports passing arbitrary sized structures to userland. Additionally, only our reader will get it so that multiple unrelated eBPF programs can produce data concurrently without issues.&lt;/p&gt;

&lt;p&gt;To use it, we need to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;define a structure&lt;/li&gt;
&lt;li&gt;declare the event&lt;/li&gt;
&lt;li&gt;push the event&lt;/li&gt;
&lt;li&gt;re-declare the event on Python&amp;rsquo;s side (This step should go away in the future)&lt;/li&gt;
&lt;li&gt;consume and format the event&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This may seem like a lot, but it ain&amp;rsquo;t. See:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// At the begining of the C program, declare our event
struct listen_evt_t {
    u64 laddr;
    u64 lport;
    u64 netns;
    u64 backlog;
};
BPF_PERF_OUTPUT(listen_evt);

// In kprobe__inet_listen, replace the printk with
struct listen_evt_t evt = {
    .laddr = ntohl(laddr),
    .lport = ntohs(lport),
    .netns = netns,
    .backlog = backlog,
};
listen_evt.perf_submit(ctx, &amp;amp;evt, sizeof(evt));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python side will require a little more work, though:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# We need ctypes to parse the event structure
import ctypes

# Declare data format
class ListenEvt(ctypes.Structure):
    _fields_ = [
        (&amp;quot;laddr&amp;quot;,   ctypes.c_ulonglong),
        (&amp;quot;lport&amp;quot;,   ctypes.c_ulonglong),
        (&amp;quot;netns&amp;quot;,   ctypes.c_ulonglong),
        (&amp;quot;backlog&amp;quot;, ctypes.c_ulonglong),
    ]

# Declare event printer
def print_event(cpu, data, size):
    event = ctypes.cast(data, ctypes.POINTER(ListenEvt)).contents
    print(&amp;quot;Listening on %x %d with %d pending connections in container %d&amp;quot; % (
        event.laddr,
        event.lport,
        event.backlog,
        event.netns,
    ))

# Replace the event loop
b[&amp;quot;listen_evt&amp;quot;].open_perf_buffer(print_event)
while True:
    b.kprobe_poll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Give it a try. In this example, I have a redis running in a docker container and nc on the host:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(bcc)ubuntu@bcc:~/dev/listen-evts$ sudo python tcv4listen.py
Listening on 0 6379 with 128 pending connections in container 4026532165
Listening on 0 6379 with 128 pending connections in container 4026532165
Listening on 7f000001 6588 with 1 pending connections in container 4026531957
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;last-word:30fe7a87f2e63f2b769ee3edffa56012&#34;&gt;Last word&lt;/h3&gt;

&lt;p&gt;Absolutely everything is now setup to use trigger events from arbitrary function calls in the kernel using eBPF, and you should have seen most of the common pitfalls I hit while learning eBPF. If you want to see the full version of this tool, along with some more tricks like IPv6 support, have a look at &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/tools/solisten.py&#34;&gt;https://github.com/iovisor/bcc/blob/master/tools/solisten.py&lt;/a&gt;. It&amp;rsquo;s now an official tool, thanks to the support of the bcc team.&lt;/p&gt;

&lt;p&gt;To go further, you may want to checkout Brendan Gregg&amp;rsquo;s blog, in particular &lt;a href=&#34;http://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html&#34;&gt;the post about eBPF maps and statistics&lt;/a&gt;. He his one of the project&amp;rsquo;s main contributor.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to seccomp: BPF linux syscall filter</title>
      <link>http://blog.yadutaf.fr/2014/05/29/introduction-to-seccomp-bpf-linux-syscall-filter/</link>
      <pubDate>Thu, 29 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.yadutaf.fr/2014/05/29/introduction-to-seccomp-bpf-linux-syscall-filter/</guid>
      <description>&lt;p&gt;Seccomp is basic yet efficient way to filter syscalls issued by a program. It is especially useful when running untrusted third party programs. Actually, it was first &lt;a href=&#34;http://git.kernel.org/cgit/linux/kernel/git/tglx/history.git/commit/?id=d949d0ec9c601f2b148bed3cdb5f87c052968554&#34; title=&#34;Initial seccomp commit&#34;&gt;introduced in linux 2.6.12&lt;/a&gt; as an essential building block of &lt;a href=&#34;http://mashable.com/2005/12/21/cpushare-distributed-computing-marketplace/&#34;&gt;&amp;#8220;cpushare&amp;#8221; program&lt;/a&gt;. The idea behind this project was to allow anyone with the proper agent installed to rent cpu cycles to third parties, without compromising its the security.&lt;/p&gt;

&lt;p&gt;The initial implementation, also known as &amp;#8220;mode 1 seccomp&amp;#8221; only allowed &amp;#8216;&lt;code&gt;read&lt;/code&gt;&amp;#8216;, &amp;#8216;&lt;code&gt;write&lt;/code&gt;&amp;#8216;, &amp;#8216;&lt;code&gt;_exit&lt;/code&gt;&amp;#8216; and &amp;#8216;&lt;code&gt;sigreturn&lt;/code&gt;&amp;#8216; syscalls to be issued making it only possible to read/write to already opened files and to exit. It is also trivial get started with:&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; highlight: [2,3,10]; title: 01-nothing.c; notranslate&#34; title=&#34;01-nothing.c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;         /* printf */
#include &amp;lt;sys/prctl.h&amp;gt;     /* prctl */
#include &amp;lt;linux/seccomp.h&amp;gt; /* seccomp&#39;s constants */
#include &amp;lt;unistd.h&amp;gt;        /* dup2: just for test */

int main() {
  printf(&#34;step 1: unrestricted\n&#34;);

  // Enable filtering
  prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);
  printf(&#34;step 2: only &#39;read&#39;, &#39;write&#39;, &#39;_exit&#39; and &#39;sigreturn&#39; syscalls\n&#34;);
  
  // Redirect stderr to stdout
  dup2(1, 2);
  printf(&#34;step 3: !! YOU SHOULD NOT SEE ME !!\n&#34;);

  // Success (well, not so in this case...)
  return 0; 
}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Build, run, test:&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;brush: bash; title: ; notranslate&#34; title=&#34;&#34;&gt;gcc 01-nothing.c -o 01-nothing &amp;&amp; ./01-nothing; echo &#34;Status: $?&#34;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;brush: plain; title: ; notranslate&#34; title=&#34;&#34;&gt;step 1: unrestricted
step 2: only &#39;read&#39;, &#39;write&#39;, &#39;_exit&#39; and &#39;sigreturn&#39; syscalls
Processus arrêté
Status: 137        &amp;lt;------ 128+9 ==&amp;gt; SIGKILL
&lt;/pre&gt;

&lt;p&gt;See the return status ? Whenever a forbidden syscall is issued, the program is immediately killed.&lt;/p&gt;

&lt;p&gt;While this is really cool, this is also somewhat over-restrictive. This is the reason why it saw such a little adoption. Linus Torvald even suggested to ax it out of the kernel!&lt;/p&gt;

&lt;p&gt;Fortunately, since linux 3.5, it is also possible to define advanced custom filters based on the BPF (Berkley Packet Filters). These filters may apply on any of the syscall argument but only on their value. In other words, a filter won&amp;rsquo;t be able to dereference a pointer. For example one could write a rule to forbid any call to &amp;#8216;&lt;code&gt;dup2&lt;/code&gt;&amp;#8216; as long as it targets &amp;#8216;&lt;code&gt;stderr&lt;/code&gt;&amp;#8216; (fd=2) but would not be able to restrict &amp;#8216;&lt;code&gt;open&lt;/code&gt;&amp;#8216; to a given set of files neither bind to a specific interface or port number.&lt;/p&gt;

&lt;p&gt;Once installed, each syscall is sent to the filter which tells what action to take:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SECCOMP_RET_KILL&lt;/code&gt;: Immediate kill with SIGSYS&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECCOMP_RET_TRAP&lt;/code&gt;: Send a catchable SIGSYS, giving a chance to emulate the syscall&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECCOMP_RET_ERRNO&lt;/code&gt;: Force &lt;code&gt;errno&lt;/code&gt; value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECCOMP_RET_TRACE&lt;/code&gt;: Yield decision to ptracer or set &lt;code&gt;errno&lt;/code&gt; to &lt;code&gt;-ENOSYS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECCOMP_RET_ALLOW&lt;/code&gt;: Allow&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Enough words. Let&amp;rsquo;s allow the program to redirect its &lt;code&gt;stderr&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt; but nothing else. Writing BPF directly is cumbersome and far beyond the scope of this post, we&amp;rsquo;ll use the &lt;code&gt;libseccomp&lt;/code&gt; helper to make the code easier to write&amp;#8230; and read. Error checking stripped for brevity.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Grab the library:&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;brush: bash; title: ; notranslate&#34; title=&#34;&#34;&gt;sudo apt-get install libseccomp-dev&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Write the code:&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; title: 02-bpf-only-dup-sudo.c; notranslate&#34; title=&#34;02-bpf-only-dup-sudo.c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;   /* printf */
#include &amp;lt;unistd.h&amp;gt;  /* dup2: just for test */
#include &amp;lt;seccomp.h&amp;gt; /* libseccomp */

int main() {
  printf(&#34;step 1: unrestricted\n&#34;);

  // Init the filter
  scmp_filter_ctx ctx;
  ctx = seccomp_init(SCMP_ACT_KILL); // default action: kill

  // setup basic whitelist
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0);
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);
  
  // setup our rule
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(dup2), 2, 
                        SCMP_A0(SCMP_CMP_EQ, 1),
                        SCMP_A1(SCMP_CMP_EQ, 2));

  // build and load the filter
  seccomp_load(ctx);
  printf(&#34;step 2: only &#39;write&#39; and dup2(1, 2) syscalls\n&#34;);
  
  // Redirect stderr to stdout
  dup2(1, 2);
  printf(&#34;step 3: stderr redirected to stdout\n&#34;);

  // Duplicate stderr to arbitrary fd
  dup2(2, 42);
  printf(&#34;step 4: !! YOU SHOULD NOT SEE ME !!\n&#34;);

  // Success (well, not so in this case...)
  return 0; 
}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Build, run, test:&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;brush: bash; title: ; notranslate&#34; title=&#34;&#34;&gt;gcc 02-bpf-only-dup-sudo.c -o 02-bpf-only-dup-sudo -lseccomp &amp;&amp; sudo ./02-bpf-only-dup-sudo; echo &#34;Status: $?&#34;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;brush: plain; title: ; notranslate&#34; title=&#34;&#34;&gt;step 1: unrestricted
step 2: only &#39;write&#39; and dup2(1, 2) syscalls
step 3: stderr redirected to stdout
Appel système erroné
Status: 159        &amp;lt;------ 128+31 ==&amp;gt; SIGSYS
&lt;/pre&gt;

&lt;p&gt;Just as expected.&lt;/p&gt;

&lt;p&gt;As you probably noticed, we ran the previous example as root which somewhat limits the security benefice of syscall filtering as we actually have MORE privileges than before&amp;#8230;&lt;/p&gt;

&lt;p&gt;This is where it really gets interesting: filters are inherited by child processes so that one could technically apply syscall filters to &amp;#8216;sudo&amp;rsquo; and maybe defeat some of its security measures and gain root on the machine ? To prevent this, one must either be &amp;#8216;&lt;code&gt;CAP_SYS_ADMIN&lt;/code&gt;&amp;#8216; (read: root), either explicitly accept to never get any more privileges. For example the &amp;#8216;&lt;code&gt;setuid&lt;/code&gt;&amp;#8216; bit of &amp;#8216;&lt;code&gt;sudo&lt;/code&gt;&amp;#8216; would not be honored.&lt;/p&gt;

&lt;p&gt;This can easily be achieved by adding this snippet &lt;em&gt;before&lt;/em&gt; installing the filter:&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; title: ; notranslate&#34; title=&#34;&#34;&gt;prctl(PR_SET_NO_NEW_PRIVS, 1);&lt;/pre&gt;

&lt;p&gt;Another security note, remember the &lt;code&gt;SECCOMP_RET_TRACE&lt;/code&gt; filter return value ? It instructs the kernel to notify the ptracer program, if any, to take the final decision. Hence the &amp;#8220;secured&amp;#8221; program could be run under a malicious ptracer possibly defeating the security measures. This is why another &lt;code&gt;prctl&lt;/code&gt; is highly recommended to forbid any attempt to attach a ptracer:&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; title: ; notranslate&#34; title=&#34;&#34;&gt;prctl(PR_SET_DUMPABLE, 0);&lt;/pre&gt;

&lt;p&gt;Putting it all together we get:&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; title: 03-bpf-only-dup.c; notranslate&#34; title=&#34;03-bpf-only-dup.c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;     /* printf */
#include &amp;lt;unistd.h&amp;gt;    /* dup2: just for test */
#include &amp;lt;seccomp.h&amp;gt;   /* libseccomp */
#include &amp;lt;sys/prctl.h&amp;gt; /* prctl */

int main() {
  printf(&#34;step 1: unrestricted\n&#34;);

  // ensure none of our children will ever be granted more priv
  // (via setuid, capabilities, ...)
  prctl(PR_SET_NO_NEW_PRIVS, 1);
  // ensure no escape is possible via ptrace
  prctl(PR_SET_DUMPABLE, 0);

  // Init the filter
  scmp_filter_ctx ctx;
  ctx = seccomp_init(SCMP_ACT_KILL); // default action: kill

  // setup basic whitelist
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0);
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);
  
  // setup our rule
  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(dup2), 2, 
                        SCMP_A0(SCMP_CMP_EQ, 1),
                        SCMP_A1(SCMP_CMP_EQ, 2));

  // build and load the filter
  seccomp_load(ctx);
  printf(&#34;step 2: only &#39;write&#39; and dup2(1, 2) syscalls\n&#34;);
  
  // Redirect stderr to stdout
  dup2(1, 2);
  printf(&#34;step 3: stderr redirected to stdout\n&#34;);

  // Duplicate stderr to arbitrary fd
  dup2(2, 42);
  printf(&#34;step 4: !! YOU SHOULD NOT SEE ME !!\n&#34;);

  // Success (well, not so in this case...)
  return 0;
}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Build, run, test:&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;brush: bash; title: ; notranslate&#34; title=&#34;&#34;&gt;gcc 03-bpf-only-dup.c -o 03-bpf-only-dup -lseccomp &amp;&amp; ./03-bpf-only-dup; echo &#34;Status: $?&#34;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Output:&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;brush: plain; title: ; notranslate&#34; title=&#34;&#34;&gt;step 1: unrestricted
step 2: only &#39;write&#39; and dup2(1, 2) syscalls
step 3: stderr redirected to stdout
Appel système erroné
Status: 159        &amp;lt;------ 128+31 ==&amp;gt; SIGSYS
&lt;/pre&gt;

&lt;p&gt;There we are: no more &amp;#8220;sudo&amp;#8221; to run it &lt;img src=&#34;https://blog.jtlebi.fr/wp-includes/images/smilies/simple-smile.png&#34; alt=&#34;:)&#34; class=&#34;wp-smiley&#34; style=&#34;height: 1em; max-height: 1em;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Linux&amp;rsquo;s seccomp is an extremely powerful tool when dealing with untrusted program&amp;rsquo;s on Linux. (who said in &amp;#8220;shared hosting environment&amp;#8221;?). And we only scratched its surface. Please, keep in mind that seccomp is only a tool and should be used in combination with other Linux&amp;rsquo;s security building blocks such as &lt;a href=&#34;https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/&#34; title=&#34;Introduction to Linux namespaces – Part 1: UTS&#34;&gt;namespaces&lt;/a&gt; and capabilities to unleash its full power.&lt;/p&gt;

&lt;p&gt;Example applications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;prevent &amp;#8220;virtual priv esc&amp;#8221; -&amp;gt; clone &amp;amp;&amp;amp; unshare CLONE_NEW_USER&lt;/li&gt;
&lt;li&gt;prevent std{in,out,err} escape -&amp;gt; block &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;dup2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;restrict read/write to std{in,out,err}&lt;/li&gt;
&lt;li&gt;change limits (rlimits)&lt;/li&gt;
&lt;li&gt;&amp;#8230; -&amp;gt; see man 2 syscalls for more ideas 😉&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What you still can&amp;rsquo;t do:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;filter base on filename: no pointer dereference&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;filter base on port/ip: same reason&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Going further:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://sourceforge.net/p/libseccomp/libseccomp/ci/master/tree/tests/&#34;&gt;libseccomp tests&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kernel seccomp &lt;a href=&#34;https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt&#34;&gt;documentation&lt;/a&gt; and &lt;a href=&#34;https://github.com/torvalds/linux/tree/master/samples/seccomp&#34;&gt;samples&lt;/a&gt; (low level BPF)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ptrace interaction: overcome the &amp;#8220;What you still can&amp;rsquo;t do&amp;#8221; section.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to Linux namespaces – Part 5: NET</title>
      <link>http://blog.yadutaf.fr/2014/01/19/introduction-to-linux-namespaces-part-5-net/</link>
      <pubDate>Sun, 19 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.yadutaf.fr/2014/01/19/introduction-to-linux-namespaces-part-5-net/</guid>
      <description>&lt;p&gt;Following the &lt;a href=&#34;https://blog.jtlebi.fr/2014/01/12/introduction-to-linux-namespaces-part-4-ns-fs/&#34; title=&#34;Introduction to Linux namespaces – Part 4: PID&#34;&gt;previous post on PID namespace&lt;/a&gt; (Restart process numbering to &amp;#8220;1&amp;#8221;), would like to go further and fly eve closer to full-featured VMs ? Great ! The two last posts of this series will precisely focus on this. Isolate network interfaces with the &amp;#8220;NET&amp;#8221; namespace (Yes, really) and user/group identifier for even more transparency. If you haven&amp;rsquo;t done so already, I encourage you to read &lt;a href=&#34;https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/&#34; title=&#34;Introduction to Linux namespaces – Part 1: UTS&#34;&gt;the first post of this series for an introduction to linux namespace isolation mechanism&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[EDIT 2014-01-08] A Chinese translation of this post is available &lt;a href=&#34;http://blog.lucode.net/linux/intro-Linux-namespace-5.html&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For once we won&amp;rsquo;t start with the addition of the &amp;#8220;CLONE_NEWNET&amp;#8221; flag to the &amp;#8220;clone&amp;#8221; syscall. I keep it for later. For now, IMHO, the best way to get started with this namespace is the incredibly mighty &amp;#8220;&lt;a href=&#34;http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2&#34; title=&#34;IPRoute2 official website&#34;&gt;iproute2&lt;/a&gt;&amp;#8221; net-admin swiss army knife. If you don&amp;rsquo;t have it (yet) I highly encourage you to install it. Nonetheless, if don&amp;rsquo;t want to / can&amp;rsquo;t, you may as well skip the explanation part and go straight to the full code sample.&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s see what network interfaces we have at the moment:&lt;/p&gt;

&lt;pre class=&#34;brush: bash; title: ; notranslate&#34; title=&#34;&#34;&gt;ip link list&lt;/pre&gt;

&lt;p&gt;Which outputs something like:&lt;/p&gt;

&lt;pre class=&#34;brush: plain; title: ; notranslate&#34; title=&#34;&#34;&gt;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc pfifo_fast state DOWN mode DEFAULT qlen 1000
    link/ether **:**:**:**:**:** brd ff:ff:ff:ff:ff:ff
3: wlan0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc mq state UP mode DORMANT qlen 1000
    link/ether **:**:**:**:**:** brd ff:ff:ff:ff:ff:ff
# ...
&lt;/pre&gt;

&lt;p&gt;Nothing unexpected here. I have a working loopback, UP (Yeah, &amp;#8216;UNKNOWN&amp;rsquo; means &amp;#8216;UP&amp;rsquo;&amp;#8230;) and am connected to my wireless network + a couple of extra connections eclipsed for this article.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s create a network namespace and run the same from inside:&lt;/p&gt;

&lt;pre class=&#34;brush: bash; title: ; notranslate&#34; title=&#34;&#34;&gt;# create a network namespace called &#34;demo&#34;
ip netns add demo
# exec &#34;ip link list&#34; inside the namespace
ip netns exec demo ip link list
&lt;/pre&gt;

&lt;p&gt;Output is now:&lt;/p&gt;

&lt;pre class=&#34;brush: plain; title: ; notranslate&#34; title=&#34;&#34;&gt;1: lo: &amp;lt;LOOPBACK&amp;gt; mtu 65536 qdisc noop state DOWN mode DEFAULT 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
&lt;/pre&gt;

&lt;p&gt;Huuu, not only is there only a loopback but also it is &amp;#8220;DOWN&amp;#8221;. Even more interesting, it is fully isolated from the main loopback. That is to say, any application inside the namespace binding on &amp;#8220;the&amp;#8221; loopback would only be able to communicate with applications inside the same namespace. Exactly the same level of isolation as with the IPC namespace. Neat, isnt&amp;rsquo;t ?&lt;/p&gt;

&lt;p&gt;Right, but how do I communicate with the interwebz now ?&lt;/p&gt;

&lt;p&gt;There are multiple solutions. The easiest and most common one is to create a Point-to-Point tunnel between your &amp;#8220;Host&amp;#8221; and &amp;#8220;Guest&amp;#8221; system. Once, again, the Linux Kernel provides multiple alternatives. I recommend to use the &amp;#8220;veth&amp;#8221; interfaces as these are the best integrated in the ecosystem especially with iproute2. This is also an extremely well tested piece of code as it is used by LXC and actually comes from the &lt;a href=&#34;http://openvz.org&#34; title=&#34;OpenVZ offical website&#34;&gt;OpenVZ project&lt;/a&gt;. Another alternative could be the &amp;#8220;etun&amp;#8221; driver. It conceptually is the same with another name but I&amp;rsquo;m not aware of any project using it.&lt;/p&gt;

&lt;p&gt;Both &amp;#8220;veth&amp;#8221; and &amp;#8220;etun&amp;#8221; create a pair of virtual interfaces linked on with the other in the current namespace. You can then pick one and move it in the target namespace to get a communication channel. You could think of it as intricate particles if it makes it easier to understand ;).&lt;/p&gt;

&lt;p&gt;The next step is to give them an IP, set them up and ping ! Here is an example bash session doing just that:&lt;/p&gt;

&lt;pre class=&#34;brush: bash; title: ; notranslate&#34; title=&#34;&#34;&gt;# Create a &#34;demo&#34; namespace
ip netns add demo

# create a &#34;veth&#34; pair
ip link add veth0 type veth peer name veth1

# and move one to the namespace
ip link set veth1 netns demo

# configure the interfaces (up + IP)
ip netns exec demo ip link set lo up
ip netns exec demo ip link set veth1 up
ip netns exec demo ip addr add 169.254.1.2/30 dev veth1
ip link set veth0 up
ip addr add 169.254.1.1/30 dev veth0
&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it ! Nothing scary.&lt;/p&gt;

&lt;p&gt;If you need to get Internet access from the &amp;#8220;guest&amp;#8221; system using the &amp;#8220;veth&amp;#8221; technique, you could setup masquerding, commonly known as &amp;#8220;NAT&amp;#8221;. In the same way, to make a webserver listening on the :80 inside the namespace appear to listen directly on the main interface, one could use &amp;#8220;DNAT&amp;#8221; commonly known as port &amp;#8220;forwarding&amp;#8221;. I&amp;rsquo;ll leave this up to the reader.&lt;/p&gt;

&lt;p&gt;Here is a basic example to quickly get started:&lt;/p&gt;

&lt;pre class=&#34;brush: bash; title: ; notranslate&#34; title=&#34;&#34;&gt;# make sure ip forwarding is enabled
echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
# enable Internet access for the namespace, assuming you ran the previous example
iptables -t nat -A POSTROUTING -i veth0 -j  MASQUERADE
# Forward main &#34;:80&#34; to guest &#34;:80&#34;
iptables -t nat -A PREROUTING -d &amp;lt;your main ip&amp;gt;/32 -p tcp --dport 80 -j  DNAT --to-destination  169.254.1.2:80
&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s put it all together and finally append the &lt;code&gt;CLONE_NEWNET&lt;/code&gt; flag to the &lt;code&gt;clone&lt;/code&gt; syscall. For the sake of simplicity we&amp;rsquo;ll simply stick with direct calls to &amp;#8220;ip&amp;#8221; using the &lt;code&gt;system()&lt;/code&gt; syscall.&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; highlight: [9,40,41,42,57,60,61,62,63,64,65,66]; title: main-5-net.c; notranslate&#34; title=&#34;main-5-net.c&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;sys/mount.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

#define STACK_SIZE (1024 * 1024)

// sync primitive
int checkpoint[2];

static char child_stack[STACK_SIZE];
char* const child_args[] = {
  &#34;/bin/bash&#34;,
  NULL
};

int child_main(void* arg)
{
  char c;

  // init sync primitive
  close(checkpoint[1]);

  // setup hostname
  printf(&#34; - [%5d] World !\n&#34;, getpid());
  sethostname(&#34;In Namespace&#34;, 12);

  // remount &#34;/proc&#34; to get accurate &#34;top&#34; &amp;&amp; &#34;ps&#34; output
  mount(&#34;proc&#34;, &#34;/proc&#34;, &#34;proc&#34;, 0, NULL);

  // wait for network setup in parent
  read(checkpoint[0], &amp;c, 1);

  // setup network
  system(&#34;ip link set lo up&#34;);
  system(&#34;ip link set veth1 up&#34;);
  system(&#34;ip addr add 169.254.1.2/30 dev veth1&#34;);

  execv(child_args[0], child_args);
  printf(&#34;Ooops\n&#34;);
  return 1;
}

int main()
{
  // init sync primitive
  pipe(checkpoint);

  printf(&#34; - [%5d] Hello ?\n&#34;, getpid());

  int child_pid = clone(child_main, child_stack+STACK_SIZE,
      CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | SIGCHLD, NULL);

  // further init: create a veth pair
  char* cmd;
  asprintf(&amp;cmd, &#34;ip link set veth1 netns %d&#34;, child_pid);
  system(&#34;ip link add veth0 type veth peer name veth1&#34;);
  system(cmd);
  system(&#34;ip link set veth0 up&#34;);
  system(&#34;ip addr add 169.254.1.1/30 dev veth0&#34;);
  free(cmd);

  // signal &#34;done&#34;
  close(checkpoint[1]);

  waitpid(child_pid, NULL, 0);
  return 0;
}
&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s give it a test run !&lt;/p&gt;

&lt;pre class=&#34;brush: bash; title: ; notranslate&#34; title=&#34;&#34;&gt;jean-tiare@jeantiare-Ubuntu:~/blog$ gcc -Wall main.c -o ns &amp;&amp; sudo ./ns
 - [22094] Hello ?
 - [    1] World !
root@In Namespace:~/blog$ # run a super-powerful server, fully isolated
root@In Namespace:~/blog$ nc -l 4242
Hi !
Bye...
root@In Namespace:~/blog$ exit
jean-tiare@jeantiare-Ubuntu:~/blog$ # done !
&lt;/pre&gt;

&lt;p&gt;This is what you would have seen if, from another terminal, you had:&lt;/p&gt;

&lt;pre class=&#34;brush: bash; title: ; notranslate&#34; title=&#34;&#34;&gt;jean-tiare@jeantiare-Ubuntu:~$ nc 169.254.1.2 4242
Hi !    
Bye...
jean-tiare@jeantiare-Ubuntu:~$ 
&lt;/pre&gt;

&lt;p&gt;To go further on the path to network virtualization, you could have a look at new interfaces types recently introduced in the Linux kernel: macvlan, vlan, vxlans, &amp;#8230;&lt;/p&gt;

&lt;p&gt;If you feel that running a bunch of &lt;code&gt;system()&lt;/code&gt; calls into a production system is a dirty hack (and it is !), you could have look at the &lt;code&gt;rtnetlink&lt;/code&gt; kernel communication interface. This is the barely documented API used by iproute under the hood.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all for &amp;#8220;NET&amp;#8221; namespace. It&amp;rsquo;s so powerful that it&amp;rsquo;s used as the foundation of the &lt;a href=&#34;http://cs.itd.nrl.navy.mil/work/core/index.php&#34;&gt;&amp;#8220;CORE&amp;#8221; lightweight network simulator&lt;/a&gt;. With the next article we&amp;rsquo;ll explore the last and most tricky namespace &amp;#8220;USER&amp;#8221;. Thanks for reading !&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to Linux namespaces - Part 4: NS (FS)</title>
      <link>http://blog.yadutaf.fr/2014/01/12/introduction-to-linux-namespaces-part-4-ns-fs/</link>
      <pubDate>Sun, 12 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.yadutaf.fr/2014/01/12/introduction-to-linux-namespaces-part-4-ns-fs/</guid>
      <description>&lt;p&gt;Following the &lt;a href=&#34;https://blog.jtlebi.fr/2014/01/05/introduction-to-linux-namespaces-part-3-pid/&#34; title=&#34;Introduction to Linux namespaces – Part 4: NS (FS)&#34;&gt;previous post on FS namespace&lt;/a&gt; (mountpoints table isolation), we will now have a look at an amazing one: isolated mount table. If you haven&amp;rsquo;t done so already, I encourage you to read &lt;a href=&#34;https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/&#34; title=&#34;Introduction to Linux namespaces – Part 1: UTS&#34;&gt;the first post of this series for an introduction to linux namespace isolation mechanism&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[EDIT 2014-01-08] A Chinese translation of this post is available &lt;a href=&#34;http://blog.lucode.net/linux/intro-Linux-namespace-4.html&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In the previous post we &amp;#8220;chrooted&amp;#8221; the PID namespace and got a new &amp;#8220;1&amp;#8221; process. But even with this namespace activated, there still lacked isolation for tools like &amp;#8220;top&amp;#8221; because they rely on the &amp;#8220;/proc&amp;#8221; virtual filesystem which is still shared (identical) between namespaces. In this post, let me introduce the namespace that will solve this: &amp;#8220;NS&amp;#8221;. This is historically the first Linux Namespace, hence the name.&lt;/p&gt;

&lt;p&gt;Activating it is only a matter of adding &amp;#8220;CLONE_NEWNS&amp;#8221; to the &amp;#8220;clone&amp;#8221; call. It requires no additional setup. It may also be freely combined with other namespaces.&lt;/p&gt;

&lt;p&gt;Once activated, any (un)mount operations from the child will only affect the child and vice-versa.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start experimenting. In the previous example, just activate the NS:&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; first-line: 43; title: activate-ns-snippet.c; notranslate&#34; title=&#34;activate-ns-snippet.c&#34;&gt;int child_pid = clone(child_main, child_stack+STACK_SIZE, 
      CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);
&lt;/pre&gt;

&lt;p&gt;Now, if we run it, we finally can fix the issue from the previous post on PID:&lt;/p&gt;

&lt;pre class=&#34;brush: plain; highlight: [4,7,8]; title: ; notranslate&#34; title=&#34;&#34;&gt;jean-tiare@jeantiare-Ubuntu:~/blog$ gcc -Wall ns.c -o ns &amp;&amp; sudo ./ns
 - [14472] Hello ?
 - [    1] World !
root@In Namespace:~/blog# mount -t proc proc /proc
root@In Namespace:~/blog# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  1.0  0.0  23620  4680 pts/4    S    00:07   0:00 /bin/bash
root        79  0.0  0.0  18492  1328 pts/4    R+   00:07   0:00 ps aux
root@In Namespace:~/blog# exit
&lt;/pre&gt;

&lt;p&gt;Tadaaa ! &amp;#8220;/proc&amp;#8221; is now working as expected from the container, without breaking the parent.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s automate it to finalize previous post&amp;rsquo;s example:&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; highlight: [4,33,51]; title: main-4-ns.c; notranslate&#34; title=&#34;main-4-ns.c&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;sys/mount.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

#define STACK_SIZE (1024 * 1024)

// sync primitive
int checkpoint[2];

static char child_stack[STACK_SIZE];
char* const child_args[] = {
  &#34;/bin/bash&#34;,
  NULL
};

int child_main(void* arg)
{
  char c;

  // init sync primitive
  close(checkpoint[1]);

  // setup hostname
  printf(&#34; - [%5d] World !\n&#34;, getpid());
  sethostname(&#34;In Namespace&#34;, 12);

  // remount &#34;/proc&#34; to get accurate &#34;top&#34; &amp;&amp; &#34;ps&#34; output
  mount(&#34;proc&#34;, &#34;/proc&#34;, &#34;proc&#34;, 0, NULL);

  // wait...
  read(checkpoint[0], &amp;c, 1);

  execv(child_args[0], child_args);
  printf(&#34;Ooops\n&#34;);
  return 1;
}

int main()
{
  // init sync primitive
  pipe(checkpoint);

  printf(&#34; - [%5d] Hello ?\n&#34;, getpid());

  int child_pid = clone(child_main, child_stack+STACK_SIZE,
      CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);

  // further init here (nothing yet)

  // signal &#34;done&#34;
  close(checkpoint[1]);

  waitpid(child_pid, NULL, 0);
  return 0;
}
&lt;/pre&gt;

&lt;p&gt;If you run this snippet, you should get exactly the same behavior as the previous test without manually remounting &amp;#8220;/proc&amp;#8221; neither messing with your real parent&amp;rsquo;s &amp;#8220;/proc&amp;#8221;. Neat isn&amp;rsquo;t it ?&lt;/p&gt;

&lt;p&gt;To leverage the power of this technique you could now prepare and enter a chroot to further enhance the isolation. Steps involved would be to prepare a &amp;#8220;debootstrap&amp;#8221;, remount some essentials filesystems like &amp;#8220;/tmp&amp;#8221;, &amp;#8220;/dev/shm&amp;#8221;, &amp;#8220;/proc&amp;#8221;, optionally all or part of &amp;#8220;/dev&amp;#8221; and &amp;#8220;/sys&amp;#8221; and then &amp;#8220;&lt;a href=&#34;http://linux.die.net/man/2/chdir&#34; title=&#34;man chdir&#34;&gt;chdir&lt;/a&gt;&amp;#8221; + &amp;#8220;&lt;a href=&#34;http://linux.die.net/man/1/chroot&#34; title=&#34;man Chroot&#34;&gt;chroot&lt;/a&gt;&amp;#8220;. I&amp;rsquo;ll leave it as an exercise for the reader.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all for &amp;#8220;NS&amp;#8221; namespace. With the next article we&amp;rsquo;ll explore an incredibly powerful namespace &amp;#8220;NET&amp;#8221;. It&amp;rsquo;s so powerful that it&amp;rsquo;s used as the foundation of the &lt;a href=&#34;http://cs.itd.nrl.navy.mil/work/core/index.php&#34;&gt;&amp;#8220;CORE&amp;#8221; lightweight network simulator&lt;/a&gt;. Thanks for reading !&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to Linux namespaces - Part 3: PID</title>
      <link>http://blog.yadutaf.fr/2014/01/05/introduction-to-linux-namespaces-part-3-pid/</link>
      <pubDate>Sun, 05 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.yadutaf.fr/2014/01/05/introduction-to-linux-namespaces-part-3-pid/</guid>
      <description>&lt;p&gt;Following the &lt;a href=&#34;https://blog.jtlebi.fr/2013/12/28/introduction-to-linux-namespaces-part-2-ipc/&#34; title=&#34;Introduction to Linux namespaces – Part 2: IPC&#34;&gt;previous post on IPC namespace&lt;/a&gt; (Inter Process Communication isolation), I would now like to introduce my personal favorite one (as sysadmin): PID namespaces. If you haven&amp;rsquo;t done so already, I encourage you to read &lt;a href=&#34;https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/&#34; title=&#34;Introduction to Linux namespaces – Part 1: UTS&#34;&gt;the first post of this series for an introduction to linux namespace isolation mechanism&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[EDIT 2014-01-08] A Chinese translation of this post is available &lt;a href=&#34;http://blog.lucode.net/linux/intro-Linux-namespace-3.html&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Yes, that&amp;rsquo;s it, with this namespace it is possible to restart PID numbering and get your own &amp;#8220;1&amp;#8221; process. This could be seen as a &amp;#8220;chroot&amp;#8221; in the process identifier tree. It&amp;rsquo;s extremely handy when you need to deal with pids in day to day work and are stuck with 4 digits numbers&amp;#8230;&lt;/p&gt;

&lt;p&gt;Activating it is only a matter of adding &amp;#8220;CLONE_NEWPID&amp;#8221; to the &amp;#8220;clone&amp;#8221; call. It requires no additional setup. It may also be freely combined with other namespaces.&lt;/p&gt;

&lt;p&gt;Once activated, the result of getpid() from child process will invariably be &amp;#8220;1&amp;#8221;.&lt;/p&gt;

&lt;p&gt;But, WAIT! I know have to &amp;#8220;1&amp;#8221; process right ? What about process management ?&lt;/p&gt;

&lt;p&gt;Well, actually, this *really* is much like a &amp;#8220;chroot&amp;#8221;. That is to say, a change of view point.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Host: &lt;em&gt;all&lt;/em&gt; processes are visible, &lt;em&gt;global&lt;/em&gt; PIDs (init=1, &amp;#8230;, child=xxx, &amp;#8230;.)&lt;/li&gt;
&lt;li&gt;Container: &lt;em&gt;only child + descendant&lt;/em&gt; are visible, local PIDs (child=1, &amp;#8230;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is an illustration:&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; highlight: [29,41,44]; title: ; notranslate&#34; title=&#34;&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

#define STACK_SIZE (1024 * 1024)

// sync primitive
int checkpoint[2];

static char child_stack[STACK_SIZE];
char* const child_args[] = {
  &#34;/bin/bash&#34;,
  NULL
};

int child_main(void* arg)
{
  char c;

  // init sync primitive
  close(checkpoint[1]);
  // wait...
  read(checkpoint[0], &amp;c, 1);

  printf(&#34; - [%5d] World !\n&#34;, getpid());
  sethostname(&#34;In Namespace&#34;, 12);
  execv(child_args[0], child_args);
  printf(&#34;Ooops\n&#34;);
  return 1;
}

int main()
{
  // init sync primitive
  pipe(checkpoint);

  printf(&#34; - [%5d] Hello ?\n&#34;, getpid());

  int child_pid = clone(child_main, child_stack+STACK_SIZE,
      CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | SIGCHLD, NULL);

  // further init here (nothing yet)

  // signal &#34;done&#34;
  close(checkpoint[1]);

  waitpid(child_pid, NULL, 0);
  return 0;
}
&lt;/pre&gt;

&lt;p&gt;And an example run:&lt;/p&gt;

&lt;pre class=&#34;brush: plain; title: ; notranslate&#34; title=&#34;&#34;&gt;jean-tiare@jeantiare-Ubuntu:~/blog$ gcc -Wall main-3-pid.c -o ns &amp;&amp; sudo ./ns
 - [ 7823] Hello ?
 - [    1] World !
root@In Namespace:~/blog# echo &#34;=&amp;gt; My PID: $$&#34;
=&amp;gt; My PID: 1
root@In Namespace:~/blog# exit
&lt;/pre&gt;

&lt;p&gt;As expected, even thought the parent process as a PID of &amp;#8220;7823&amp;#8221;, the child&amp;rsquo;s PID is &amp;#8220;1&amp;#8221;. If you are playfull, you could try to &amp;#8220;kill -KILL 7823&amp;#8221; the parent process. It would do exactly&amp;#8230; nothing:&lt;/p&gt;

&lt;pre class=&#34;brush: plain; title: ; notranslate&#34; title=&#34;&#34;&gt;jean-tiare@jeantiare-Ubuntu:~/blog$ gcc -Wall main-3-pid.c -o ns &amp;&amp; sudo ./ns
 - [ 7823] Hello ?
 - [    1] World !
root@In Namespace:~/blog# kill -KILL 7823
bash: kill: (7823) - No such process
root@In Namespace:~/blog# exit
&lt;/pre&gt;

&lt;p&gt;The isolation is working as expected. And, as written earlier, this behaves much like a &amp;#8220;chroot&amp;#8221; meaning that with a &amp;#8220;top&amp;#8221; or &amp;#8220;ps exf&amp;#8221; from the parent process will show the child process with its real un-mapped PID. This is an essential feature for process control like &amp;#8220;kill&amp;#8221;, &amp;#8220;cgroups&amp;#8221;, &amp;#8230; and various policies.&lt;/p&gt;

&lt;p&gt;Wait! Speaking of &amp;#8220;top&amp;#8221; and &amp;#8220;ps exf&amp;#8221;, I just ran them from the child and saw exactly the same as from the parent. You lied to me about isolation !&lt;/p&gt;

&lt;p&gt;Well, not at all. This is because these tools get their informations from the virtual &amp;#8220;/proc&amp;#8221; filesystem which is not (yet) isolated. This is the purpose of the next article.&lt;/p&gt;

&lt;p&gt;In the mean time, an easy workaround could be:&lt;/p&gt;

&lt;pre class=&#34;brush: plain; highlight: [3,5]; title: ; notranslate&#34; title=&#34;&#34;&gt;# from child
root@In Namespace:~/blog# mkdir -p proc
root@In Namespace:~/blog# mount -t proc proc proc
root@In Namespace:~/blog# ls proc
1          dma          key-users      net            sysvipc
80         dri          kmsg           pagetypeinfo   timer_list
acpi       driver       kpagecount     partitions     timer_stats
asound     execdomains  kpageflags     sched_debug    tty
buddyinfo  fb           latency_stats  schedstat      uptime
bus        filesystems  loadavg        scsi           version
cgroups    fs           locks          self           version_signature
cmdline    interrupts   mdstat         slabinfo       vmallocinfo
consoles   iomem        meminfo        softirqs       vmstat
cpuinfo    ioports      misc           stat           zoneinfo
crypto     irq          modules        swaps
devices    kallsyms     mounts         sys
diskstats  kcore        mtrr           sysrq-trigger
&lt;/pre&gt;

&lt;p&gt;Everything seems reasonable again. As expected, you get PID &amp;#8220;1&amp;#8221; for /bin/bash itself and &amp;#8220;80&amp;#8221; corresponds to the running &amp;#8220;/bin/ls proc&amp;#8221; command. Much nicer to read than usual /proc, isn&amp;rsquo;t it ? That&amp;rsquo;s why I love it.&lt;/p&gt;

&lt;p&gt;If you attempt to run this command directly on the &amp;#8220;/proc&amp;#8221; from the namespace, it will &lt;em&gt;seem&lt;/em&gt; to work in the child but BREAK your main namespace. Example:&lt;/p&gt;

&lt;pre class=&#34;brush: plain; title: ; notranslate&#34; title=&#34;&#34;&gt;jean-tiare@jeantiare-Ubuntu:~/blog$ ps aux
Error, do this: mount -t proc proc /proc
&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all for PID namespace. With the next article, we&amp;rsquo;ll be able to re-mount /proc itself and hence fix &amp;#8220;top&amp;#8221; and any similar tools without breaking the parent namespace. Thanks for reading !&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to Linux namespaces - Part 2: IPC</title>
      <link>http://blog.yadutaf.fr/2013/12/28/introduction-to-linux-namespaces-part-2-ipc/</link>
      <pubDate>Sat, 28 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.yadutaf.fr/2013/12/28/introduction-to-linux-namespaces-part-2-ipc/</guid>
      <description>&lt;p&gt;Following the &lt;a href=&#34;https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/&#34; title=&#34;Introduction to Linux namespaces – Part 1: UTS&#34;&gt;previous post on UTS namespace&lt;/a&gt; (hostname isolation), we will now go deeper and look at a more security oriented namespace: IPC, Inter-Process Communications. If you haven&amp;rsquo;t done so already, I encourage you to read &lt;a href=&#34;https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/&#34; title=&#34;Introduction to Linux namespaces – Part 1: UTS&#34;&gt;the first post of this series for an introduction to linux namespace isolation mechanism&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[EDIT 2014-01-08] A Chinese translation of this post is available &lt;a href=&#34;http://blog.lucode.net/linux/intro-Linux-namespace-2.html&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Activating the IPC namespace is only a matter of adding &amp;#8220;CLONE_NEWIPC&amp;#8221; to the &amp;#8220;clone&amp;#8221; call. It requires no additional setup. It may also be freely combined with other namespaces.&lt;/p&gt;

&lt;p&gt;Once activated, you are free to create any IPC as usual, even named one, without any risk of collision with other applications.&lt;/p&gt;

&lt;p&gt;But, WAIT! My &amp;#8220;parent process&amp;#8221; is now isolated from my &amp;#8220;child process&amp;#8221; right ? What if I need to do some kind of communication between them ?&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a good question. A common use case for this is you need some additional setup from the parent before letting the child take full control. Fortunately, not everything is isolated and clone shares memory space with its parent so that you can still use:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;signal&lt;/li&gt;
&lt;li&gt;poll memory&lt;/li&gt;
&lt;li&gt;sockets&lt;/li&gt;
&lt;li&gt;use files and file-descriptors&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because of it&amp;rsquo;s context changes, signaling is probably not the most practical one while polling memory is damn inefficient way of communicating !&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t plan to fully isolate the network stack, you could go with sockets. Same remark applies with filesystem. But, in the case of this series this is precisely what we intend to do: isolate everything, step by step.&lt;/p&gt;

&lt;p&gt;A little known / rarely used solution is to watch events on a pipe pair. In fact this is the technique used (with no explanation) by Lennart Poettering in &lt;a href=&#34;http://cgit.freedesktop.org/systemd/systemd/tree/src/nspawn/nspawn.c&#34; title=&#34;systemd nspawn - git&#34;&gt;Systemd&amp;rsquo;s &amp;#8220;nspawn&amp;#8221;&lt;/a&gt; command. This is an extremely powerful technique that I would like to introduce here. This is also the one we will rely upon in the next articles.&lt;/p&gt;

&lt;p&gt;We first need to init a pair of pipes. Let&amp;rsquo;s call them a &amp;#8220;checkpoint&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; title: checkpoint-global-init.c; notranslate&#34; title=&#34;checkpoint-global-init.c&#34;&gt;// required headers: 
#include &amp;lt;unistd.h&amp;gt;

// global status:
int checkpoint[2];

// [parent] init:
pipe(checkpoint);
&lt;/pre&gt;

&lt;p&gt;The idea is to trigger a &amp;#8220;close&amp;#8221; event from the parent and wait for &amp;#8220;EOF&amp;#8221; to be received on the reading end, in the child. Something crucial to understand is that *all* writing file-descriptors must be closed for an EOF to be received. Hence, the first thing to do before waiting in the child is to close our own write fd copy.&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; title: checkpoint-child-init.c; notranslate&#34; title=&#34;checkpoint-child-init.c&#34;&gt;// required headers: 
#include &amp;lt;unistd.h&amp;gt;

// [child] init:
close(checkpoint[1]);
&lt;/pre&gt;

&lt;p&gt;Actual &amp;#8220;signaling&amp;#8221; is now straightforward:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;close write fd in parent&lt;/li&gt;
&lt;li&gt;wait for EOF from child&lt;/li&gt;
&lt;/ol&gt;

&lt;pre class=&#34;brush: cpp; title: checkpoint-signal.c; notranslate&#34; title=&#34;checkpoint-signal.c&#34;&gt;// required headers: 
#include &amp;lt;unistd.h&amp;gt;

// [child] wait:
char c; // stub char
read(checkpoint[0], &amp;c, 1);

// [parent] signal ready code:
close(checkpoint[1]);
&lt;/pre&gt;

&lt;p&gt;If we put it together the first example on UTS namespace, it could look like:&lt;/p&gt;

&lt;pre class=&#34;brush: cpp; highlight: [7,12,25,27,39,49]; title: main-2-ipc.c; notranslate&#34; title=&#34;main-2-ipc.c&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

#define STACK_SIZE (1024 * 1024)

// sync primitive
int checkpoint[2];

static char child_stack[STACK_SIZE];
char* const child_args[] = {
  &#34;/bin/bash&#34;,
  NULL
};

int child_main(void* arg)
{
  char c;

  // init sync primitive
  close(checkpoint[1]);
  // wait...
  read(checkpoint[0], &amp;c, 1);

  printf(&#34; - World !\n&#34;);
  sethostname(&#34;In Namespace&#34;, 12);
  execv(child_args[0], child_args);
  printf(&#34;Ooops\n&#34;);
  return 1;
}

int main()
{
  // init sync primitive
  pipe(checkpoint);

  printf(&#34; - Hello ?\n&#34;);

  int child_pid = clone(child_main, child_stack+STACK_SIZE,
      CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, NULL);

  // some damn long init job
  sleep(4);
  // signal &#34;done&#34;
  close(checkpoint[1]);

  waitpid(child_pid, NULL, 0);
  return 0;
}
&lt;/pre&gt;

&lt;p&gt;As this requires advanced capabilities, this snippets needs root or equivalent privileges to run. Obviously, there is no need to keep &amp;#8220;CLONE_NEWUTS&amp;#8221; in this example. I kept it only to show that multiple namespaces may be used together.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all for IPC. IPC in itself is nothing complicated. It just becomes tricky when it comes to parent/child synchronization as we will do later. This is where the &amp;#8220;pipe&amp;#8221; technique comes as a handy solution. It actually works and is used in production.&lt;/p&gt;

&lt;p&gt;The next article will be on my favorite one (as sysadmin): PID namespaces.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>