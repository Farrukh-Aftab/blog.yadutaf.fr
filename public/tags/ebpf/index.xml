<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ebpf on Yet another enthusiast blog!</title>
    <link>http://blog.yadutaf.fr/tags/ebpf/index.xml</link>
    <description>Recent content in Ebpf on Yet another enthusiast blog!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Jean-Tiare Le Bigot</copyright>
    <atom:link href="http://blog.yadutaf.fr/tags/ebpf/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tracing a packet journey thanks to eBPF</title>
      <link>http://blog.yadutaf.fr/2017/07/11/tracing-a-packet-journey-thanks-to-ebpf/</link>
      <pubDate>Tue, 11 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>http://blog.yadutaf.fr/2017/07/11/tracing-a-packet-journey-thanks-to-ebpf/</guid>
      <description>

&lt;p&gt;If you do networking, you are used to long debugging sessions, firing up a couple of &lt;code&gt;tcpdump&lt;/code&gt;, &lt;code&gt;mtr&lt;/code&gt; and &lt;code&gt;*ping&lt;/code&gt; along the expected/actual packet journey. At least, when there is routing involved, &lt;code&gt;mtr&lt;/code&gt; (or &lt;code&gt;traceroute&lt;/code&gt; if you have no choice) does a good at showing what&amp;rsquo;s going on. But not everything is L3. Since containers became popular on Linux, people found new &amp;lsquo;exciting&amp;rsquo; ways to torture the networking subsystem with (powerful) virtual interfaces like veth, macvlan bridge, V(x)LAN, &amp;hellip; Add a bunch of network namespaces [&lt;strong&gt;TODO LINK TO POST&lt;/strong&gt;] in the equation and debugging starts to get&amp;hellip; interesting. If not excitingly frustrating.&lt;/p&gt;

&lt;p&gt;When I was working for OVH, I designed a significant part of the inner networking of the next generation of Load Balancers. Without revealing trade secrets / announcing not-yet-if-ever-released products, I can tell that it involved a fair amount of network namespaces, virtual interfaces and truly nasty routing tricks (like routing via an interface with no IP and using &lt;code&gt;dummy&lt;/code&gt; interfaces). At least, it did not involve multiple routing tables (at that time). For all this time, I whished I had a tool to trace a packet journey across the interfaces and network namespaces.&lt;/p&gt;

&lt;p&gt;Latter, I was struggling with a network issue in a trivial 2 nodes Docker Swarm setup I use to play around &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:play-around&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:play-around&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Exactly half the connections timed out. It turned out to be the kind of bugs you end up fixing by rebooting&amp;hellip; the other node. Frustrating. I whished I had a tool to trace a packet journey across the interfaces and network namespaces.&lt;/p&gt;

&lt;p&gt;In such situation, one usually ends up checking manually each possible ip route, ip table, iptables, iptables tables (!) in each possible network namespace / vrf, possibly firing a couple of tcpdumps as an attempt to make sense of the problem. Feels like a maze. At least, it does to me. You have to guess a path, check it, rinse, repeat. At least, in an actual maze, you can cheat by looking from above. &lt;code&gt;tcpdump&lt;/code&gt; would be a good tool even though tracing is not the area where it excels. To get the &amp;ldquo;view from above&amp;rdquo;, you could make it listen on the special &amp;ldquo;any&amp;rdquo; interface. But that won&amp;rsquo;t help when using multiple network namespaces. You&amp;rsquo;d need 1 tcpdump instance per network namespace. Doable. But cumbersome.&lt;/p&gt;

&lt;h3 id=&#34;the-solution-enter-ebpf&#34;&gt;The solution: Enter eBPF&lt;/h3&gt;

&lt;p&gt;Then, it hit me. When I wrote the solisten.py [&lt;strong&gt;TODO LINK TO POST&lt;/strong&gt;] tool to notify whenever a programs starts to listen on any network interface, in any network namespace, I used eBPF to hook on the main listen function in the kernel (inet_listen [&lt;strong&gt;TODO LINK TO KERNEL SOURCE&lt;/strong&gt;]) and send events. Maybe we can do the same to trace a packet? Sounds reasonable!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s define the problem. We want to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Trace a packet journey in the kernel, on a single node&lt;/li&gt;
&lt;li&gt;List all crossed interface&lt;/li&gt;
&lt;li&gt;List all crossed network namespace&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ok, now that the problem is defined, this looks more like a trackable problem. Let&amp;rsquo;s translate these goals to needs. We need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use bcc [&lt;strong&gt;TODO LINK TO BCC PROJECT&lt;/strong&gt;]. It comes with a C to eBPF compiler and a Python API. Seems reasonable for prototyping.&lt;/li&gt;
&lt;li&gt;Trace ping packets. They are well known, have no side effect, contain an &amp;ldquo;identifier&amp;rdquo; and &amp;ldquo;sequence&amp;rdquo; field.&lt;/li&gt;
&lt;li&gt;Find a function that is (almost) always called when a packet is queued on an interface. That would solve the &amp;ldquo;all crossed interface and network namespace&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To keep things simple, distributed, TCP and UDP tracing are out of the scope. That would be perfectly feasible, but that would also be over-engineering in that specific case. Additionally, even though I did my proof of concept with IPv6 and IPv4 support, I&amp;rsquo;ll focus exclusively on IPv4 in the post for the sake of readability and link to the final code at the end of this post for curious people [&lt;strong&gt;TODO LINK TO THE FULL CODE&lt;/strong&gt;].&lt;/p&gt;

&lt;h3 id=&#34;find-a-function-to-trace&#34;&gt;Find a function to trace&lt;/h3&gt;

&lt;p&gt;We need a good function to trace. Long story short, we&amp;rsquo;ll use &lt;code&gt;dev_hard_start_xmit&lt;/code&gt; on Linux 4.10 [&lt;strong&gt;TODO LINK&lt;/strong&gt;] for the sake of this post. This may not be the best / perfect pick. But it does the job.&lt;/p&gt;

&lt;p&gt;As digging in the kernel source may seem intimidating, I&amp;rsquo;d like to broadly re-trace the process of finding one, in the hope it can help you find one next time you need to.&lt;/p&gt;

&lt;p&gt;There are some constraints. We need a function that is never inlined. If it is inlined, it is potentially present in all the calling site and maybe optimized away. Moreover, it can not be a &amp;ldquo;static&amp;rdquo; function. Static functions are basically the C equivalent of private function in most languages. All in all, if the candidate is not present in &lt;code&gt;/proc/kallsyms&lt;/code&gt;, it won&amp;rsquo;t work. Some of them are special and can&amp;rsquo;t be traced either, but we&amp;rsquo;ll leave it aside.&lt;/p&gt;

&lt;p&gt;Additionally, if possible, we&amp;rsquo;d prefer a function that is common to all or most of the devices and code path to limit the number of functions to trace. This is not a hard constraint, but that would surely help!&lt;/p&gt;

&lt;p&gt;As I add no clue behind looking into &amp;ldquo;/net&amp;rdquo;, I started from the veth driver. It looked like a reasonable candidate to start. This is a reasonably simple virtual driver, there should not be too much noise in it. Use &amp;lsquo;find&amp;rsquo; to locate it and there you are &lt;a href=&#34;http://elixir.free-electrons.com/linux/v4.10.17/source/drivers/net/veth.c&#34;&gt;http://elixir.free-electrons.com/linux/v4.10.17/source/drivers/net/veth.c&lt;/a&gt;. Around 500 lines of code. For the kernel, that&amp;rsquo;s pretty small. Nice. Now, we need to check the functions in this file, looking for some good looking name. A good looking name would suggest that this function queues or forwards a packet on this interface. Good news, there is a single candidate, &amp;ldquo;vethxmit&amp;rdquo; &lt;a href=&#34;http://elixir.free-electrons.com/linux/v4.10.17/source/drivers/net/veth.c#L106&#34;&gt;http://elixir.free-electrons.com/linux/v4.10.17/source/drivers/net/veth.c#L106&lt;/a&gt;. As this is a driver, if this function is actually the one used by to enqueue packets, it will be registered somewhere and called via a function pointer. This the kernel&amp;rsquo;s way to interfaces. A few lines below, it is registered under the name &amp;lsquo;ndo_start_xmit&amp;rsquo; &lt;a href=&#34;http://elixir.free-electrons.com/linux/v4.10.17/source/drivers/net/veth.c#L291&#34;&gt;http://elixir.free-electrons.com/linux/v4.10.17/source/drivers/net/veth.c#L291&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Some &amp;lsquo;grep&amp;rsquo; later, we learn that &lt;code&gt;ndo_start_xmit()&lt;/code&gt; is mostly called from &lt;code&gt;__netdev_start_xmit&lt;/code&gt; in &lt;a href=&#34;http://elixir.free-electrons.com/linux/v4.10.17/source/include/linux/netdevice.h&#34;&gt;http://elixir.free-electrons.com/linux/v4.10.17/source/include/linux/netdevice.h&lt;/a&gt;. There are 2 other call sites but they are related to usb and infiniband. We&amp;rsquo;ll ignore them for now. Bad news is, this is a static inline function. We&amp;rsquo;ll need another candidate.&lt;/p&gt;

&lt;p&gt;This function is called from a couple of places [&lt;a href=&#34;http://elixir.free-electrons.com/linux/v4.10.17/ident/netdev_start_xmit&#34;&gt;http://elixir.free-electrons.com/linux/v4.10.17/ident/netdev_start_xmit&lt;/a&gt;]. There are multiple good candidates here. I guess we&amp;rsquo;d need to trace at least a couple of them. But we&amp;rsquo;ll start with the most likely candidate and maybe add more later. We&amp;rsquo;ll go for &lt;code&gt;xmit_one&lt;/code&gt; in &lt;a href=&#34;http://elixir.free-electrons.com/linux/v4.10.17/source/net/core/dev.c#L2905&#34;&gt;http://elixir.free-electrons.com/linux/v4.10.17/source/net/core/dev.c#L2905&lt;/a&gt;. Unfortunately, this function is static, hence private, hence untraceable. On the bright side, it&amp;rsquo;s static so we know all call sites must be in the same module. In our case, there is a single call place in &lt;code&gt;dev_hard_start_xmit&lt;/code&gt; &lt;a href=&#34;http://elixir.free-electrons.com/linux/v4.10.17/source/net/core/dev.c#L2922&#34;&gt;http://elixir.free-electrons.com/linux/v4.10.17/source/net/core/dev.c#L2922&lt;/a&gt;. a quick grep in &lt;code&gt;/proc/kallsyms&lt;/code&gt; confirms this simple is exported: we have our candidate!&lt;/p&gt;

&lt;h3 id=&#34;install-bcc&#34;&gt;Install bcc&lt;/h3&gt;

&lt;p&gt;If you already have it installed or are not intending to experiment (yet) on this PoC, you can safely skip this section. I should probably just skip it entirely anyway but install instruction are not exactly up to date. Hence, here is an updated, quick and dirty &amp;trade; procedure for Ubuntu 17.04 (Zesty).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install dependencies
sudo apt install bison build-essential cmake flex git libedit-dev python zlib1g-dev libelf-dev libllvm4.0 llvm-dev libclang-dev luajit luajit-5.1-dev

# Grab the sources
git clone https://github.com/iovisor/bcc.git

# Build and install
mkdir bcc/build
cd bcc/build
cmake .. -DCMAKE_INSTALL_PREFIX=/usr
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On Ubuntu 16.10 (Xenial) and older, install llvm3.7 instead.&lt;/p&gt;

&lt;h3 id=&#34;trace-dev-hard-start-xmit-using-bcc&#34;&gt;Trace &lt;code&gt;dev_hard_start_xmit&lt;/code&gt; using bcc&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s the fun part. We&amp;rsquo;ll attach a kernel probe (kprobe, you guessed it :)) to &lt;code&gt;dev_hard_start_xmit&lt;/code&gt; and start building some events from the probe. Then we&amp;rsquo;ll use a piece of simple Python code to parse these events and print some info.&lt;/p&gt;

&lt;p&gt;Even though probes look like regular C and is indeed build using a LLVM C compiler, this is only a restricted subset of C that compiles to eBPF. That is, a simple VM inside the kernel designed to allow safe observers (ie: not actors / modifiers) to look around, provided the meet some criterions. First, most loops won&amp;rsquo;t be allowed, the kernels needs to prove the program will always exit before starting it. Second, this is an observing program. You can not call arbitrary kernel functions for obvious security reasons. Some inline accessors defined in &amp;ldquo;.h&amp;rdquo; files are OK though. Third, you can not access memory outside the probe stack. If you need to do so, you need to be explicit about it and use bpf accessors. More on this later.&lt;/p&gt;

&lt;p&gt;With this in place, we can proceed with a hello world probe. We&amp;rsquo;ll simply emit an event for each packet sent (don&amp;rsquo;t run it on a production system!). This event will only contain the owning programm name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;bcc/proto.h&amp;gt;
#include &amp;lt;linux/sched.h&amp;gt;

// Event structure
struct route_evt_t {
    char comm[TASK_COMM_LEN];
};
BPF_PERF_OUTPUT(route_evt);

int kprobe__dev_hard_start_xmit(struct pt_regs *ctx, struct sk_buff *first, struct net_device *dev, struct netdev_queue *txq, int *ret)
{
    // Built event for userland
    struct route_evt_t evt = {};
    bpf_get_current_comm(evt.comm, TASK_COMM_LEN);

    // Send event to userland
    route_evt.perf_submit(ctx, &amp;amp;evt, sizeof(evt));

    return 0;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look at what it does.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Grab some definitions, just like a regular C program&lt;/li&gt;
&lt;li&gt;Declare out event structure (&lt;code&gt;struct route_evt_t&lt;/code&gt;) and channel name (&lt;code&gt;BPF_PERF_OUTPUT(route_evt)&lt;/code&gt;)
3/ Declare our probe (&lt;code&gt;kprobe__dev_hard_start_xmit&lt;/code&gt;). Notice the &lt;code&gt;kprobe__&lt;/code&gt; prefix and &lt;code&gt;struct pt_regs *ctx&lt;/code&gt; argument. bcc automatically detects the prefix and attaches it to the proper kernel function and will pass the context as first argument.
4/ Use a special bpf helper function (&lt;code&gt;bpf_get_current_comm&lt;/code&gt;) to load the program name into the event structure. This is one of the rare function that can be called from eBPF!
5/ Send the event (&lt;code&gt;route_evt.perf_submit()&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We can now integrate it in a simple Python program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# coding: utf-8

from socket import inet_ntop
from bcc import BPF
import ctypes as ct

bpf_text = &#39;&#39;&#39;&amp;lt;SEE CODE SNIPPET ABOVE&amp;gt;&#39;&#39;&#39;

TASK_COMM_LEN = 16 # linux/sched.h

class RouteEvt(ct.Structure):
    _fields_ = [
        (&amp;quot;comm&amp;quot;,    ct.c_char * TASK_COMM_LEN),
    ]

def event_printer(cpu, data, size):
    # Decode event
    event = ct.cast(data, ct.POINTER(RouteEvt)).contents

    # Print event
    print &amp;quot;Just go a packet from %s&amp;quot; % (event.comm)

if __name__ == &amp;quot;__main__&amp;quot;:
    b = BPF(text=bpf_text)
    b[&amp;quot;route_evt&amp;quot;].open_perf_buffer(event_printer)

    while True:
        b.kprobe_poll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I won&amp;rsquo;t go too much into the details, here, this is mostly self-explanatory. This is basically te mirror of the setup on the eBPF side. Declare the event structure using ctypes to decode it, declare the probe, listen for events and print them.&lt;/p&gt;

&lt;p&gt;If you run this program (as root), you&amp;rsquo;ll probably see something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Just go a packet from ping
Just go a packet from ping
Just go a packet from Socket Thread
Just go a packet from irq/46-iwlwifi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll notice that I have a ping running in the background and using WiFi. So you can rightfully guess I&amp;rsquo;m typing from this from my laptop. Indeed, eBPF is not reserved to datacenters :)&lt;/p&gt;

&lt;h3 id=&#34;load-interface-name-netns-id-from-ipv4-packets&#34;&gt;Load interface name, netns id from IPv4 packets&lt;/h3&gt;

&lt;p&gt;Once the plumbing is in place this is straightforward. If we can call straightforward to parse network packets from kernel structures :p. In this section, I&amp;rsquo;ll focus on &lt;code&gt;kprobe__dev_hard_start_xmit&lt;/code&gt; in the C/eBPF part of the probe. The structure and Python part can be easily extended. I&amp;rsquo;ll put a link to a complete version at the end of the post.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start by keeping only IPv4 packets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Cast types. Intermediate cast not needed, kept for readability
struct sock *sk = first-&amp;gt;sk;

// Filter IPv4 packets
if (sk-&amp;gt;sk_family != AF_INET) {
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, there is no choice, you need to read the structure definitions in the kernel. Fortunately, this is one of the most active and documented subsystem of Linux.&lt;/p&gt;

&lt;p&gt;While dealing with &lt;code&gt;sk&lt;/code&gt;, we can grab the network namespace internal identifier. This will not give you a pretty name like &lt;code&gt;ip netns&lt;/code&gt; does, that&amp;rsquo;s only a magic trick. Rather, it will return the numerical part of what you can see when using &lt;code&gt;readlink&lt;/code&gt; on some &lt;code&gt;/proc/[PID]/ns/net&lt;/code&gt; pseudo file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Get netns id
evt.netns = sk-&amp;gt;sk_net.net-&amp;gt;ns.inum;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Granted, this may require quite a bit of detective work to find! While we are at the low hanging fruits, we can load the interface name into the event structure as well, from the device:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Get interface name
bpf_probe_read(&amp;amp;evt.ifname, IFNAMSIZ, dev-&amp;gt;name);
__builtin_memcpy(&amp;amp;evt.ifname, dev-&amp;gt;name, IFNAMSIZ);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the &lt;code&gt;bpf_probe_read&lt;/code&gt; function. This is the helper to use when reading data. It will handle the memory safety checks for you so that the kernel can trust your code, even though it may access memory outside the eBPF stack. Alternatively, you could use &lt;code&gt;__builtin_memcpy&lt;/code&gt; as well. Actually, this is what I used initially. But it feels hackish. Failing to do so may result in strange build errors like &amp;ldquo;error: extraneous closing brace (&amp;lsquo;}&amp;rsquo;)&amp;rdquo; if you used the more familiar &amp;ldquo;memcpy&amp;rdquo; or &amp;ldquo;Permission Denied&amp;rdquo; from the kernel if it failed to prove safe memory access at validation time, before your code even get a chance to run.&lt;/p&gt;

&lt;h3 id=&#34;keep-only-icmp-echo-request-ping-and-echo-replies&#34;&gt;Keep only ICMP echo request (ping) and echo replies&lt;/h3&gt;

&lt;p&gt;With these gratifying low hanging fruits in hands, we can focus on the packet itself. Depending on you point of view when reading this post, it may seem trivial or&amp;hellip; disheartening, wondering how one can find the necessary fields and offsets. I generally fall into the second category. That&amp;rsquo;s OK. You may use kernel structures for IP and ICMP to guess the fields and Wikipedia has really high quality pages about these foundation protocols.&lt;/p&gt;

&lt;p&gt;Enough talking. Let&amp;rsquo;s get started. First, step, some grounding work. Let&amp;rsquo;s compute the IPv4 and ICMP headers addresses:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Pre-Compute header addresses
char* ip_header_address   = first-&amp;gt;head + first-&amp;gt;network_header;
char* icmp_header_address = first-&amp;gt;head + first-&amp;gt;transport_header;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the manual inlining of &lt;code&gt;skb_network_header()&lt;/code&gt; and &lt;code&gt;skb_transport_header()&lt;/code&gt;. Although both are static inline, we can unfortunately not use them here. If we do, the kernel will complain about &amp;ldquo;R1 invalid mem access &amp;lsquo;inv&amp;rsquo;&amp;rdquo;. I suspect this is a compiler glitch as the code are strictly equivalent. Keep in mind eBPF and it&amp;rsquo;s bcc frontends are quite recent additions.&lt;/p&gt;

&lt;p&gt;On the a side note, I accidentally lost quite some time using &lt;code&gt;first-&amp;gt;data&lt;/code&gt; instead of &lt;code&gt;first-&amp;gt;head&lt;/code&gt;. The former is the head of the buffer from which all offsets are computed, while the later is the offset of the first &amp;ldquo;meaningful&amp;rdquo; byte in the buffer.&lt;/p&gt;

&lt;p&gt;Then, load the IP header and filter ICMP packets only, using the next &lt;code&gt;protocol&lt;/code&gt; field from the IPv4 header. We&amp;rsquo;ll use the kernel&amp;rsquo;s &lt;code&gt;struct iphdr&lt;/code&gt; definition to get the offsets right:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Filter ICMP packets
struct iphdr* iphdr = (struct iphdr*)ip_header_address;
if (iphdr-&amp;gt;protocol != IPPROTO_ICMP) {
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may wonder why I did not write the more compact &lt;code&gt;struct iphdr* iphdr = (struct iphdr*)(first-&amp;gt;head + first-&amp;gt;network_header)&lt;/code&gt;. This is the same reason as above. The generated code would fail to pass the kernel validation phase. As it generally helps with bcc, I split the statements into smaller ones to help the verifier.&lt;/p&gt;

&lt;p&gt;We can now do the same with the ICMP header and keep only ICMP echo request and ICMP echo replies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Filter ICMP echo request and echo reply
struct icmphdr* icmphdr = (struct icmphdr*)icmp_header_address;
if (icmphdr-&amp;gt;type != ICMP_ECHO &amp;amp;&amp;amp; icmphdr-&amp;gt;type != ICMP_ECHOREPLY) {
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last but not least: load relevant data into the event.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Get address and icmp info
evt.saddr    = iphdr-&amp;gt;saddr;
evt.daddr    = iphdr-&amp;gt;daddr;
evt.icmptype = icmphdr-&amp;gt;type;
evt.icmpid   = icmphdr-&amp;gt;un.echo.id;
evt.icmpseq  = icmphdr-&amp;gt;un.echo.sequence;

// Fix endian
evt.icmpid  = be16_to_cpu(evt.icmpid);
evt.icmpseq = be16_to_cpu(evt.icmpseq);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we&amp;rsquo;re done! We now have an event ready to send to user space with all relevant information.&lt;/p&gt;

&lt;p&gt;Note: If you intend to add IPv6 support, please note that the ICMP protocol number is NOT the same as with IPv4 and echo request/replay have different op codes, even though the general packet structure looks similar. I lost quite some time on this&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;show-time&#34;&gt;Show time&lt;/h3&gt;

&lt;p&gt;With some trivial Python to handle the event, we can test it in a couple of scenarios. Start the program as root, launch some &amp;ldquo;ping&amp;rdquo; in another terminal and observe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ping -4 localhost
[  4026531957]               lo request #32693.001 127.0.0.1 -&amp;gt; 127.0.0.1
[  4026531957]               lo   reply #32693.001 127.0.0.1 -&amp;gt; 127.0.0.1
[  4026531957]               lo request #32693.002 127.0.0.1 -&amp;gt; 127.0.0.1
[  4026531957]               lo   reply #32693.002 127.0.0.1 -&amp;gt; 127.0.0.1
[  4026531957]               lo request #32693.003 127.0.0.1 -&amp;gt; 127.0.0.1
[  4026531957]               lo   reply #32693.003 127.0.0.1 -&amp;gt; 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We clearly see the first 3 ping sent the process 32693 (the ICMP id on Linux&amp;rsquo;s ping) on the loopback interface as well as the generated reply. Mission accomplished!&lt;/p&gt;

&lt;p&gt;What about some external &amp;ldquo;random&amp;rdquo; target IP?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ping -4 google.com
[  4026531957]           wlp2s0 request #31348.001 192.168.1.11 -&amp;gt; 216.58.198.206
[  4026531957]           wlp2s0 request #31348.002 192.168.1.11 -&amp;gt; 216.58.198.206
[  4026531957]           wlp2s0 request #31348.003 192.168.1.11 -&amp;gt; 216.58.198.206
[  4026531957]           wlp2s0 request #31348.004 192.168.1.11 -&amp;gt; 216.58.198.206
[  4026531957]           wlp2s0 request #31348.005 192.168.1.11 -&amp;gt; 216.58.198.206
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We clearly see the 5 first pings sent via my WiFi interface from my home network to Google. Interestingly, we don&amp;rsquo;t see the reply here. This is probably due the hypothesis we did above when choosing a function to trace. We certainly should add some tracing points to be exhaustive, but the general principle says the same. The point is proven !&lt;/p&gt;

&lt;p&gt;And my personal favorite: let&amp;rsquo;s ping a Docker container:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ping -4 172.17.0.2
[  4026531957]          docker0 request #01952.001 172.17.0.1 -&amp;gt; 172.17.0.2
[  4026531957]      veth0e65931 request #01952.001 172.17.0.1 -&amp;gt; 172.17.0.2
[  4026532395]             eth0   reply #01952.001 172.17.0.2 -&amp;gt; 172.17.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the Google example, this is not perfect BUT we do see the change of network namespace and can reasonably guess that the packet journey goes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       Host netns           | Container netns
+---------------------------+-----------------+
| docker0 ---&amp;gt; veth0e65931 ---&amp;gt; eth0          |
+---------------------------+-----------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;final-word&#34;&gt;Final word&lt;/h3&gt;

&lt;p&gt;eBPF can be used to instrument the kernel and trace the journey of an arbitrary bit of information in the kernel. I would not pretend this is a &amp;ldquo;quick way&amp;rdquo; to instrument the kernel. It&amp;rsquo;s not. And the C-like language limitations can feel frustrating at first. But once this initial frustration step is over, this is an extremely powerful tool. I hope this post gave you a good taste of it and helped ease the initial journey in eBPF. I intentionally pasted full error messages in this post in the hope they may be indexed and help you if you meet them (and you will ^^).&lt;/p&gt;

&lt;p&gt;As far as this demo is concerned, it would benefit from additional tracing point. Some packets are clearly missing. It would also be interesting to instrument the routing and filtering phases to better help troubleshoot common routing issues.&lt;/p&gt;

&lt;p&gt;I did not measure the performance impact. I know there is one. Kernel probes work by inserting jumps in the kernel on tracing points. This tracing point ends up being called for each packet. On production system that would mean a &lt;em&gt;LOT&lt;/em&gt;. It should not matter. I would not install LLVM and a build toolchain a production system for the sole sake of debugging anyway!&lt;/p&gt;

&lt;p&gt;As promised, the full code for this post is available on Github, with IPv4 and IPv6 support: &lt;a href=&#34;https://github.com/yadutaf/tracepkt&#34;&gt;https://github.com/yadutaf/tracepkt&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:play-around&#34;&gt;That is, if by &amp;ldquo;play around&amp;rdquo; you mean &amp;ldquo;host a hobby application with literally 10s of thousands clients syncing on a daily basis&amp;rdquo;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:play-around&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>How to turn any syscall into an event: Introducing eBPF Kernel probes</title>
      <link>http://blog.yadutaf.fr/2016/03/30/turn-any-syscall-into-event-introducing-ebpf-kernel-probes/</link>
      <pubDate>Wed, 30 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://blog.yadutaf.fr/2016/03/30/turn-any-syscall-into-event-introducing-ebpf-kernel-probes/</guid>
      <description>

&lt;p&gt;TL;DR: Using eBPF in recent (&amp;gt;=4.4) Linux kernel, you can turn any kernel function call into a user land event with arbitrary data. This is made easy by bcc. The probe is written in C while the data is handled by python.&lt;/p&gt;

&lt;p&gt;If you are not familiar with eBPF or linux tracing, you really should read the full post. It tries to progressively go through the pitfalls I stumbled unpon while playing around with bcc / eBPF while saving you a lot of the time I spent searching and digging.&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-push-vs-pull-in-a-linux-world&#34;&gt;A note on push vs pull in a Linux world&lt;/h3&gt;

&lt;p&gt;When I started to work on containers, I was wondering how we could update a load balancer configuration dynamically based on actual system state. A common strategy, which works, it to let the container orchestrator trigger a load balancer configuration update whenever it starts a container and then let the load balancer poll the container until some health check passes. It may be a simple &amp;ldquo;SYN&amp;rdquo; test.&lt;/p&gt;

&lt;p&gt;While this configuration works, it has the downside of making your load balancer waiting for some system to be available while it should be&amp;hellip; load balancing.&lt;/p&gt;

&lt;p&gt;Can we do better?&lt;/p&gt;

&lt;p&gt;When you want a program to react to some change in a system there are 2 possible strategies. The program may &lt;em&gt;poll&lt;/em&gt; the system to detect changes or, if the system supports it, the system may &lt;em&gt;push&lt;/em&gt; events and let the program react to them. Wether you want to use push or poll depends on the context. A good rule of the thumb is to use push events when the event rate is low with respect to the processing time and switch to polling when the events are coming fast or the system may become unusable. For example, typical network driver will wait for events from the network card while frameworks like dpdk will actively poll the card for events to achieve the highest throughput and lowest latency.&lt;/p&gt;

&lt;p&gt;In an ideal world, we&amp;rsquo;d have some kernel interface telling us:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Hey Mr. ContainerManager, I&amp;rsquo;ve just created a socket for the Nginx-ware of container &lt;em&gt;servestaticfiles&lt;/em&gt;, maybe you want to update your state?&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Sure Mr. OS, Thanks for letting me know&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;While Linux has a wide range of interfaces to deal with events, up to 3 for file events, there is no dedicated interface to get socket event notifications. You can get routing table events, neighbor table events, conntrack events, interface change events. Just, not socket events. Or maybe there is, deep hidden in a Netlink interface.&lt;/p&gt;

&lt;p&gt;Ideally, we&amp;rsquo;d need a generic way to do it. How?&lt;/p&gt;

&lt;h3 id=&#34;kernel-tracing-and-ebpf-a-bit-of-history&#34;&gt;Kernel tracing and eBPF, a bit of history&lt;/h3&gt;

&lt;p&gt;Until recently the only way was to patch the kernel or resort on SystemTap. &lt;a href=&#34;https://en.wikipedia.org/wiki/SystemTap&#34;&gt;SytemTap&lt;/a&gt; is a tracing Linux system. In a nutshell, it provides a DSL which is then compiled into a kernel module which is then live-loaded into the running kernel. Except that some production system disable dynamic module loading for security reasons. Including the one I was working on at that time. The other way would be to patch the kernel to trigger some events, probably based on netlink. This is not really convenient. Kernel hacking come with downsides including &amp;ldquo;interesting&amp;rdquo; new &amp;ldquo;features&amp;rdquo; and increased maintenance burden.&lt;/p&gt;

&lt;p&gt;Hopefully, starting with Linux 3.15 the ground was laid to safely transform any traceable kernel function into userland events. &amp;ldquo;Safely&amp;rdquo; is common computer science expression referring to &amp;ldquo;some virtual machine&amp;rdquo;. This case is no exception. Linux has had one for years. Since Linux 2.1.75 released in 1997 actually. It&amp;rsquo;s called Berkeley Packet Filter of BPF for short. As its name suggests, it was originally developed for the BSD firewalls. It had only 2 registers and only allowed forward jumps meaning that you could not write loops with it (Well, you can, if you know the maximum iterations and you manually unroll them). The point was to guarantee the program would always terminate and hence never hang the system. Still not sure if it has any use while you have iptables? It serves as the &lt;a href=&#34;https://blog.cloudflare.com/bpf-the-forgotten-bytecode/&#34;&gt;foundation of CloudFlare&amp;rsquo;s AntiDDos protection&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;OK, so, with Linux the 3.15, &lt;a href=&#34;TODO&#34;&gt;BPF was extended&lt;/a&gt; turning it into eBPF. For &amp;ldquo;extended&amp;rdquo; BPF. It upgrades from 2 32 bits registers to 10 64 bits 64 registers and adds backward jumping among others. It has then been &lt;a href=&#34;https://lwn.net/Articles/604043/&#34;&gt;further extended in Linux 3.18&lt;/a&gt; moving it out of the networking subsystem, and adding tools like maps. To preserve the safety guarantees, it &lt;a href=&#34;http://lxr.free-electrons.com/source/kernel/bpf/verifier.c#L21&#34;&gt;introduces a checker&lt;/a&gt; which validates all memory accesses and possible code path. If the checker can&amp;rsquo;t guarantee the code will terminate within fixed boundaries, it will deny the initial insertion of the program.&lt;/p&gt;

&lt;p&gt;For more history, there is &lt;a href=&#34;http://events.linuxfoundation.org/sites/events/files/slides/tracing-linux-ezannoni-linuxcon-ja-2015_0.pdf&#34;&gt;an excellent Oracle presentation on eBPF&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started.&lt;/p&gt;

&lt;h3 id=&#34;hello-from-from-inet-listen&#34;&gt;Hello from from &lt;code&gt;inet_listen&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;As writing assembly is not the most convenient task, even for the best of us, we&amp;rsquo;ll use &lt;a href=&#34;https://github.com/iovisor/bcc&#34;&gt;bcc&lt;/a&gt;. bcc is a collection of tools based on LLVM and Python abstracting the underlying machinery. Probes are written in C and the results can be exploited from python allowing to easily write non trivial applications.&lt;/p&gt;

&lt;p&gt;Start by install bcc. For some of these examples, you may require a recent (read &amp;gt;= 4.4) version of the kernel. If you are willing to actually try these examples, I highly recommend that you setup a VM. &lt;em&gt;NOT&lt;/em&gt; a docker container. You can&amp;rsquo;t change the kernel in a container. As this is a young and dynamic projects, install instructions are highly platform/version dependant. You can find up to date instructions on &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/INSTALL.md&#34;&gt;https://github.com/iovisor/bcc/blob/master/INSTALL.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So, we want to get an event whenever a program starts to listen on TCP socket. When calling the &lt;code&gt;listen()&lt;/code&gt; syscall on a &lt;code&gt;AF_INET&lt;/code&gt; + &lt;code&gt;SOCK_STREAM&lt;/code&gt; socket, the underlying kernel function is &lt;a href=&#34;http://lxr.free-electrons.com/source/net/ipv4/af_inet.c#L194&#34;&gt;&lt;code&gt;inet_listen&lt;/code&gt;&lt;/a&gt;. We&amp;rsquo;ll start by hooking a &amp;ldquo;Hello World&amp;rdquo; &lt;code&gt;kprobe&lt;/code&gt; on it&amp;rsquo;s entrypoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from bcc import BPF

# Hello BPF Program
bpf_text = &amp;quot;&amp;quot;&amp;quot; 
#include &amp;lt;net/inet_sock.h&amp;gt;
#include &amp;lt;bcc/proto.h&amp;gt;

// 1. Attach kprobe to &amp;quot;inet_listen&amp;quot;
int kprobe__inet_listen(struct pt_regs *ctx, struct socket *sock, int backlog)
{
    bpf_trace_printk(&amp;quot;Hello World!\\n&amp;quot;);
    return 0;
};
&amp;quot;&amp;quot;&amp;quot;

# 2. Build and Inject program
b = BPF(text=bpf_text)

# 3. Print debug output
while True:
    print b.trace_readline()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program does 3 things:
1. It attaches a kernel probe to &amp;ldquo;inet_listen&amp;rdquo; using a naming convention. If the function was called, say, &amp;ldquo;my_probe&amp;rdquo;, it could be explicitly attached with &lt;code&gt;b.attach_kprobe(&amp;quot;inet_listen&amp;quot;, &amp;quot;my_probe&amp;quot;&lt;/code&gt;.
2. It builds the program using LLVM new BPF backend, inject the resulting bytecode using the (new) &lt;code&gt;bpf()&lt;/code&gt; syscall and automatically attaches the probes matching the naming convention.
3. It reads the raw output from the kernel pipe.&lt;/p&gt;

&lt;p&gt;Note: eBPF backend of LLVM is still young. If you think you&amp;rsquo;ve hit a bug, you may want to upgrade.&lt;/p&gt;

&lt;p&gt;Noticed the &lt;code&gt;bpf_trace_printk&lt;/code&gt; call? This is a stripped down version of the kernel&amp;rsquo;s &lt;code&gt;printk()&lt;/code&gt; debug function. When used, it produces tracing informations to a special kernel pipe in &lt;code&gt;/sys/kernel/debug/tracing/trace_pipe&lt;/code&gt;. As the name implies, this is a pipe. If multiple readers are consuming it, only 1 will get a given line. This makes it unsuitable for production.&lt;/p&gt;

&lt;p&gt;Fortunately, Linux 3.19 introduced maps for message passing and Linux 4.4 brings arbitrary perf events support. I&amp;rsquo;ll demo the perf event based approach later in this post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# From a first console
ubuntu@bcc:~/dev/listen-evts$ sudo /python tcv4listen.py 
              nc-4940  [000] d... 22666.991714: : Hello World!
 
# From a second console
ubuntu@bcc:~$ nc -l 0 4242
^C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yay!&lt;/p&gt;

&lt;h3 id=&#34;grab-the-backlog&#34;&gt;Grab the backlog&lt;/h3&gt;

&lt;p&gt;Now, let&amp;rsquo;s print some easily accessible data. Say the &amp;ldquo;backlog&amp;rdquo;. The backlog is the number of pending established TCP connections, pending to be &lt;code&gt;accept()&lt;/code&gt;ed.&lt;/p&gt;

&lt;p&gt;Just tweak a bit the &lt;code&gt;bpf_trace_printk&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bpf_trace_printk(&amp;quot;Listening with with up to %d pending connections!\\n&amp;quot;, backlog);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you re-run the example with this world-changing improvement, you should see something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(bcc)ubuntu@bcc:~/dev/listen-evts$ sudo python tcv4listen.py 
              nc-5020  [000] d... 25497.154070: : Listening with with up to 1 pending connections!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nc&lt;/code&gt; is a single connection program, hence the backlog of 1. Nginx or Redis would output 128 here. But that&amp;rsquo;s another story.&lt;/p&gt;

&lt;p&gt;Easy hue? Now let&amp;rsquo;s get the port.&lt;/p&gt;

&lt;h3 id=&#34;grab-the-port-and-ip&#34;&gt;Grab the port and IP&lt;/h3&gt;

&lt;p&gt;Studying &lt;code&gt;inet_listen&lt;/code&gt; source from the kernel, we know that we need to get the &lt;code&gt;inet_sock&lt;/code&gt; from the &lt;code&gt;socket&lt;/code&gt; object. Just copy from the sources, and insert at the beginning of the tracer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// cast types. Intermediate cast not needed, kept for readability
struct sock *sk = sock-&amp;gt;sk;
struct inet_sock *inet = inet_sk(sk);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The port can now be accessed from &lt;code&gt;inet-&amp;gt;inet_sport&lt;/code&gt; in network byte order (aka: Big Endian). Easy! So, we could just replace the &lt;code&gt;bpf_trace_printk&lt;/code&gt; with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bpf_trace_printk(&amp;quot;Listening on port %d!\\n&amp;quot;, inet-&amp;gt;inet_sport);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ubuntu@bcc:~/dev/listen-evts$ sudo /python tcv4listen.py 
...
R1 invalid mem access &#39;inv&#39;
...
Exception: Failed to load BPF program kprobe__inet_listen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Except that it&amp;rsquo;s not (yet) so simple. Bcc is improving a &lt;em&gt;lot&lt;/em&gt; currently. While writing this post, a couple of pitfalls had already been addressed. But not yet all. This Error means the in-kernel checker could prove the memory accesses in program are correct. See the explicit cast. We need to help is a little by making the accesses more explicit. We&amp;rsquo;ll use &lt;code&gt;bpf_probe_read&lt;/code&gt; trusted function to read an arbitrary memory location while guaranteeing all necessary checks are done with something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Explicit initialization. The &amp;quot;=0&amp;quot; part is needed to &amp;quot;give life&amp;quot; to the variable on the stack
u16 lport = 0;

// Explicit arbitrary memory access. Read it:
//    Read into &#39;lport&#39;, &#39;sizeof(lport)&#39; bytes from &#39;inet-&amp;gt;inet_sport&#39; memory location
bpf_probe_read(&amp;amp;lport, sizeof(lport), &amp;amp;(inet-&amp;gt;inet_sport));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reading the bound address for IPv4 is basically the same, using &lt;code&gt;inet-&amp;gt;inet_rcv_saddr&lt;/code&gt;. If we put is all together, we should get the backlog, the port and the bound IP:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from bcc import BPF  
  
# BPF Program  
bpf_text = &amp;quot;&amp;quot;&amp;quot;   
#include &amp;lt;net/sock.h&amp;gt;  
#include &amp;lt;net/inet_sock.h&amp;gt;  
#include &amp;lt;bcc/proto.h&amp;gt;  
  
// Send an event for each IPv4 listen with PID, bound address and port  
int kprobe__inet_listen(struct pt_regs *ctx, struct socket *sock, int backlog)  
{  
    // Cast types. Intermediate cast not needed, kept for readability  
    struct sock *sk = sock-&amp;gt;sk;  
    struct inet_sock *inet = inet_sk(sk);  

    // Working values. You *need* to initialize them to give them &amp;quot;life&amp;quot; on the stack and use them afterward  
    u32 laddr = 0;  
    u16 lport = 0;  

    // Pull in details. As &#39;inet_sk&#39; is internally a type cast, we need to use &#39;bpf_probe_read&#39;  
    // read: load into &#39;laddr&#39; &#39;sizeof(laddr)&#39; bytes from address &#39;inet-&amp;gt;inet_rcv_saddr&#39;  
    bpf_probe_read(&amp;amp;laddr, sizeof(laddr), &amp;amp;(inet-&amp;gt;inet_rcv_saddr));  
    bpf_probe_read(&amp;amp;lport, sizeof(lport), &amp;amp;(inet-&amp;gt;inet_sport));  

    // Push event
    bpf_trace_printk(&amp;quot;Listening on %x %d with %d pending connections\\n&amp;quot;, ntohl(laddr), ntohs(lport), backlog);  
    return 0;
};  
&amp;quot;&amp;quot;&amp;quot;  
  
# Build and Inject BPF  
b = BPF(text=bpf_text)  
  
# Print debug output  
while True:  
  print b.trace_readline()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A test run should output something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(bcc)ubuntu@bcc:~/dev/listen-evts$ sudo python tcv4listen.py 
              nc-5024  [000] d... 25821.166286: : Listening on 7f000001 4242 with 1 pending connections
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Provided that you listen on localhost. The address is displayed as hex here to avoid dealing with the IP pretty printing but that&amp;rsquo;s all wired. And that&amp;rsquo;s cool.&lt;/p&gt;

&lt;p&gt;Note: you may wonder why &lt;code&gt;ntohs&lt;/code&gt; and &lt;code&gt;ntohl&lt;/code&gt; can be called from BPF while they are not trusted. This is because they are macros and inline functions from &amp;ldquo;.h&amp;rdquo; files and a small bug was &lt;a href=&#34;https://github.com/iovisor/bcc/pull/453&#34;&gt;fixed&lt;/a&gt; while writing this post.&lt;/p&gt;

&lt;p&gt;All done, one more piece: We want to get the related container. In the context of networking, that&amp;rsquo;s means we want the network namespace. The network namespace being the building block of containers allowing them to have isolated networks.&lt;/p&gt;

&lt;h3 id=&#34;grab-the-network-namespace-a-forced-introduction-to-perf-events&#34;&gt;Grab the network namespace: a forced introduction to perf events&lt;/h3&gt;

&lt;p&gt;On the userland, the network namespace can be determined by checking the target of &lt;code&gt;/proc/PID/ns/net&lt;/code&gt;. It should look like &lt;code&gt;net:[4026531957]&lt;/code&gt;. The number between brackets is the inode number of the network namespace. This said, we could grab it by scrapping &amp;lsquo;/proc&amp;rsquo; but this is racy, we may be dealing with short-lived processes. And races are never good. We&amp;rsquo;ll grab the inode number directly from the kernel. Fortunately, that&amp;rsquo;s an easy one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Create an populate the variable
u32 netns = 0;

// Read the netns inode number, like /proc does
netns = sk-&amp;gt;__sk_common.skc_net.net-&amp;gt;ns.inum;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Easy. And it works.&lt;/p&gt;

&lt;p&gt;But if you&amp;rsquo;ve read so far, you may guess there is something wrong somewhere. And there is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bpf_trace_printk(&amp;quot;Listening on %x %d with %d pending connections in container %d\\n&amp;quot;, ntohl(laddr), ntohs(lport), backlog, netns);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you try to run it, you&amp;rsquo;ll get some cryptic error message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(bcc)ubuntu@bcc:~/dev/listen-evts$ sudo python tcv4listen.py
error: in function kprobe__inet_listen i32 (%struct.pt_regs*, %struct.socket*, i32)
too many args to 0x1ba9108: i64 = Constant&amp;lt;6&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What clang is trying to tell you is &amp;ldquo;Hey pal, &lt;code&gt;bpf_trace_printk&lt;/code&gt; can only take 4 arguments, you&amp;rsquo;ve just used 5.&amp;ldquo;. I won&amp;rsquo;t dive into the details here, but that&amp;rsquo;s a BPF limitation. If you want to dig it, &lt;a href=&#34;http://lxr.free-electrons.com/source/kernel/trace/bpf_trace.c#L86&#34;&gt;here is a good starting point&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The only way to fix it is to&amp;hellip; stop debugging and make it production ready. So let&amp;rsquo;s get started (and make sure run at least Linux 4.4). We&amp;rsquo;ll use perf events which supports passing arbitrary sized structures to userland. Additionally, only our reader will get it so that multiple unrelated eBPF programs can produce data concurrently without issues.&lt;/p&gt;

&lt;p&gt;To use it, we need to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;define a structure&lt;/li&gt;
&lt;li&gt;declare the event&lt;/li&gt;
&lt;li&gt;push the event&lt;/li&gt;
&lt;li&gt;re-declare the event on Python&amp;rsquo;s side (This step should go away in the future)&lt;/li&gt;
&lt;li&gt;consume and format the event&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This may seem like a lot, but it ain&amp;rsquo;t. See:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// At the begining of the C program, declare our event
struct listen_evt_t {
    u64 laddr;
    u64 lport;
    u64 netns;
    u64 backlog;
};
BPF_PERF_OUTPUT(listen_evt);

// In kprobe__inet_listen, replace the printk with
struct listen_evt_t evt = {
    .laddr = ntohl(laddr),
    .lport = ntohs(lport),
    .netns = netns,
    .backlog = backlog,
};
listen_evt.perf_submit(ctx, &amp;amp;evt, sizeof(evt));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python side will require a little more work, though:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# We need ctypes to parse the event structure
import ctypes

# Declare data format
class ListenEvt(ctypes.Structure):
    _fields_ = [
        (&amp;quot;laddr&amp;quot;,   ctypes.c_ulonglong),
        (&amp;quot;lport&amp;quot;,   ctypes.c_ulonglong),
        (&amp;quot;netns&amp;quot;,   ctypes.c_ulonglong),
        (&amp;quot;backlog&amp;quot;, ctypes.c_ulonglong),
    ]

# Declare event printer
def print_event(cpu, data, size):
    event = ctypes.cast(data, ctypes.POINTER(ListenEvt)).contents
    print(&amp;quot;Listening on %x %d with %d pending connections in container %d&amp;quot; % (
        event.laddr,
        event.lport,
        event.backlog,
        event.netns,
    ))

# Replace the event loop
b[&amp;quot;listen_evt&amp;quot;].open_perf_buffer(print_event)
while True:
    b.kprobe_poll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Give it a try. In this example, I have a redis running in a docker container and nc on the host:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(bcc)ubuntu@bcc:~/dev/listen-evts$ sudo python tcv4listen.py
Listening on 0 6379 with 128 pending connections in container 4026532165
Listening on 0 6379 with 128 pending connections in container 4026532165
Listening on 7f000001 6588 with 1 pending connections in container 4026531957
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;last-word&#34;&gt;Last word&lt;/h3&gt;

&lt;p&gt;Absolutely everything is now setup to use trigger events from arbitrary function calls in the kernel using eBPF, and you should have seen most of the common pitfalls I hit while learning eBPF. If you want to see the full version of this tool, along with some more tricks like IPv6 support, have a look at &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/tools/solisten.py&#34;&gt;https://github.com/iovisor/bcc/blob/master/tools/solisten.py&lt;/a&gt;. It&amp;rsquo;s now an official tool, thanks to the support of the bcc team.&lt;/p&gt;

&lt;p&gt;To go further, you may want to checkout Brendan Gregg&amp;rsquo;s blog, in particular &lt;a href=&#34;http://www.brendangregg.com/blog/2015-05-15/ebpf-one-small-step.html&#34;&gt;the post about eBPF maps and statistics&lt;/a&gt;. He his one of the project&amp;rsquo;s main contributor.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>